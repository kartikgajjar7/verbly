import * as React from 'react';
import React__default from 'react';
import { P as PlateChangeKey, a as PlateId, U as UsePlateEditorStoreOptions, b as PlateEditor, W as WithPlatePlugin, T as TEditableProps, R as RenderElementFn, c as PlateProps, d as PlatePlugin, N as NoInfer, O as OverrideByKey, C as CreatePlateEditorOptions, e as RenderElement, f as RenderLeaf } from './createPlateEditor-BNJf_PoU.js';
export { bR as ApplyDeepToNodesOptions, a8 as CARRIAGE_RETURN, bb as CollapseWhiteSpaceState, br as DOMHandler, bq as DOMHandlerReturnType, bs as DOMHandlers, bn as DOM_HANDLERS, bu as Decorate, bt as DecorateEntry, D as DefaultLeaf, bv as DeserializeHtml, ag as DeserializeHtmlChildren, ah as DeserializeHtmlNodeReturnType, E as ELEMENT_DEFAULT, bl as EXPOSED_STORE_KEYS, a1 as EventEditorState, G as GLOBAL_PLATE_SCOPE, cn as GetInjectPropsOptions, co as GetInjectPropsReturnType, bo as HandlerReturnType, bw as HotkeyPlugin, bz as InjectComponent, bx as InjectComponentProps, by as InjectComponentReturnType, bB as InjectProps, bW as InjectedPlugin, K as KEY_DESERIALIZE_AST, ae as KEY_DESERIALIZE_HTML, t as KEY_EDITOR_PROTOCOL, $ as KEY_EVENT_EDITOR, y as KEY_HISTORY, B as KEY_INLINE_VOID, J as KEY_INSERT_DATA, Q as KEY_LENGTH, X as KEY_NODE_FACTORY, Z as KEY_PREV_SELECTION, bp as KeyboardEventHandler, bC as KeyboardHandler, bD as KeyboardHandlerReturnType, a9 as LINE_FEED, M as LengthPlugin, aa as NO_BREAK_SPACE, bm as Nullable, bE as OnChange, i as PLATE_SCOPE, g as Plate, bg as PlateEditorMethods, bG as PlatePluginComponent, bI as PlatePluginInsertData, bH as PlatePluginInsertDataOptions, bK as PlatePluginKey, bL as PlatePluginProps, bh as PlateRenderElementProps, bi as PlateRenderLeafProps, bj as PlateRenderNodeProps, k as PlateStoreProvider, bk as PlateStoreState, bJ as PluginKey, bF as PluginOptions, bM as RenderAfterEditable, ab as SPACE, bN as SerializeHtml, ac as TAB, bQ as TRenderElementProps, bO as ToggleMarkPlugin, be as ToggleNodeTypeOptions, bA as TransformOptions, ba as TrimEndRule, b9 as TrimStartRule, b8 as WhiteSpaceRule, bP as WithOverride, h as WithPlateOptions, ad as ZERO_WIDTH_SPACE, bS as applyDeepToNodes, ai as cleanHtmlBrElements, aj as cleanHtmlCrLf, ak as cleanHtmlEmptyElements, al as cleanHtmlFontElements, am as cleanHtmlLinkElements, an as cleanHtmlTextNodes, a_ as collapseString, a$ as collapseWhiteSpace, b0 as collapseWhiteSpaceChildren, b1 as collapseWhiteSpaceElement, b2 as collapseWhiteSpaceNode, b3 as collapseWhiteSpaceText, ce as convertDomEventToSyntheticEvent, ao as copyBlockMarksToSpanChild, s as createDeserializeAstPlugin, af as createDeserializeHtmlPlugin, x as createEditorProtocolPlugin, a0 as createEventEditorPlugin, A as createHistoryPlugin, cr as createHotkey, H as createInlineVoidPlugin, L as createInsertDataPlugin, V as createLengthPlugin, Y as createNodeFactoryPlugin, r as createPlateEditor, j as createPlateStore, bT as createPluginFactory, bU as createPlugins, _ as createPrevSelectionPlugin, ap as deserializeHtml, aq as deserializeHtmlElement, ar as deserializeHtmlNode, as as deserializeHtmlNodeChildren, b7 as endInlineFormattingContext, a3 as eventEditorActions, a4 as eventEditorSelectors, a2 as eventEditorStore, at as findHtmlElement, bV as flattenDeepPlugins, a6 as getEventPlateId, av as getHtmlComments, bX as getInjectedPlugins, bY as getKeyByType, bZ as getKeysByTypes, b_ as getPlugin, b$ as getPluginInjectProps, c0 as getPluginOptions, c1 as getPluginType, c2 as getPluginTypes, c3 as getPlugins, c4 as getPluginsByKey, c5 as getRenderNodeProps, cu as getSlateClass, aw as htmlBodyToFragment, ax as htmlBrToNewLine, ay as htmlElementToElement, az as htmlElementToLeaf, aA as htmlStringToDOMNode, aB as htmlTextNodeToString, b4 as inferWhiteSpaceRule, aC as inlineTagNames, cf as isEventHandled, aD as isHtmlBlockElement, aE as isHtmlComment, aF as isHtmlElement, aG as isHtmlFragmentHref, aH as isHtmlInlineElement, aI as isHtmlTable, aJ as isHtmlText, b5 as isLastNonEmptyTextOfInlineFormattingContext, aK as isOlSymbol, c6 as mapInjectPropsToPlugin, c7 as mergeDeepPlugins, c8 as mergeDeepToNodes, c9 as mockPlugin, ca as normalizeDescendantsToDocumentFragment, cb as normalizeInitialValue, cc as overridePluginsByKey, aL as parseHtmlDocument, aM as parseHtmlElement, cd as pipeDecorate, aN as pipeDeserializeHtmlElement, aO as pipeDeserializeHtmlLeaf, cg as pipeHandler, ch as pipeInjectProps, ci as pipeInsertDataQuery, cj as pipeInsertFragment, ck as pipeOnChange, cl as pipeTransformData, cm as pipeTransformFragment, p as plateStore, aP as pluginDeserializeHtml, cp as pluginInjectProps, aQ as postCleanHtml, aR as preCleanHtml, aS as removeHtmlNodesBetweenComments, aT as removeHtmlSurroundings, aU as replaceTagName, bc as resetEditor, bd as resetEditorChildren, cq as setDefaultPlugin, cs as sharedHotkeys, au as someHtmlElement, bf as toggleNodeType, aV as traverseHtmlComments, aW as traverseHtmlElements, aX as traverseHtmlNode, aY as traverseHtmlTexts, aZ as unwrapHtmlElement, b6 as upsertInlineFormattingContext, a5 as useEventEditorSelectors, a7 as useFocusEditorEvents, n as usePlateActions, l as usePlateEditorStore, q as usePlateId, m as usePlateSelectors, o as usePlateStates, u as usePlateStore, v as withEditorProtocol, ct as withHOC, F as withInlineVoid, I as withInsertData, S as withLength, w as withPlate, z as withTHistory } from './createPlateEditor-BNJf_PoU.js';
import * as slate_react_dist_components_editable from 'slate-react/dist/components/editable';
import * as _udecode_slate_react from '@udecode/slate-react';
import { SlateProps, TReactEditor } from '@udecode/slate-react';
import * as _udecode_slate from '@udecode/slate';
import { TElement, Value, TEditor } from '@udecode/slate';
import * as slate from 'slate';
import * as jotai from 'jotai';
import { Atom } from 'jotai';
export { atom } from 'jotai';
import * as jotai_x from 'jotai-x';
import { JotaiStore } from 'jotai-x';
export { createAtomStore } from 'jotai-x';
export { Options as UseHotkeysOptions, isHotkeyPressed, useHotkeys } from 'react-hotkeys-hook';
import * as _udecode_utils from '@udecode/utils';
import * as jotai_vanilla_store from 'jotai/vanilla/store';
export { nanoid } from 'nanoid';
export { StateActions as ZustandStateActions, StoreApi as ZustandStoreApi, createZustandStore } from 'zustand-x';
export { isHotkey } from 'is-hotkey';
import 'slate-history';
import '@udecode/slate-utils';
import 'slate-react';

/**
 * Get the element by plugin key. If no element is found in the context, it will
 * return an empty object.
 */
declare const useElement: <T extends TElement = TElement>(pluginKey?: string) => T;

declare const SCOPE_ELEMENT = "element";
type ElementStoreState = {
    element: TElement;
};
declare const ElementProvider: React.FC<jotai_x.ProviderProps<{
    element: TElement;
}>>;
declare const useElementStore: jotai_x.UseStoreApi<ElementStoreState, object>;

declare const useIncrementVersion: (key: PlateChangeKey, id?: PlateId, options?: UsePlateEditorStoreOptions) => () => void;

declare const useRedecorate: (id?: PlateId, options?: UsePlateEditorStoreOptions) => () => void;

/** Replace plate editor with the same id and plugins. Remounts `PlateContent`. */
declare const useReplaceEditor: (id?: PlateId, options?: UsePlateEditorStoreOptions) => () => void;

declare const useEditorMounted: (id?: PlateId, options?: UsePlateEditorStoreOptions) => boolean;

/**
 * Whether the editor is read-only. You can also use `useReadOnly` from
 * `slate-react` in node components.
 */
declare const useEditorReadOnly: (id?: PlateId, options?: UsePlateEditorStoreOptions) => boolean;

/** Get editor ref which is never updated. */
declare const useEditorRef: <V extends Value = Value, E extends PlateEditor<V> = PlateEditor<V>>(id?: PlateId, options?: UsePlateEditorStoreOptions) => E;

/** Get the editor selection (deeply memoized). */
declare const useEditorSelection: (id?: PlateId, options?: UsePlateEditorStoreOptions) => any;

interface UseEditorSelectorOptions<T> extends UsePlateEditorStoreOptions {
    equalityFn?: (a: T, b: T) => boolean;
    id?: PlateId;
}
declare const useEditorSelector: <T, V extends Value = Value, E extends PlateEditor<V> = PlateEditor<V>>(selector: (editor: E, prev?: T) => T, deps: React__default.DependencyList, { equalityFn, id, ...storeOptions }?: UseEditorSelectorOptions<T>) => T;

/** Get editor state which is updated on editor change. */
declare const useEditorState: <V extends Value = Value, E extends PlateEditor<V> = PlateEditor<V>>(id?: PlateId, options?: UsePlateEditorStoreOptions) => E;

/** Version incremented on each editor change. */
declare const useEditorVersion: (id?: PlateId, options?: UsePlateEditorStoreOptions) => number | null;

/** Version incremented on selection change. */
declare const useSelectionVersion: (id?: PlateId, options?: UsePlateEditorStoreOptions) => number | null;

/** Get last event editor id: focus, blur or last. */
declare const useEventPlateId: (id?: PlateId) => string;

declare const PlateController: React__default.FC<jotai_x.ProviderProps<{
    activeId: string | null;
    editorStores: Record<string, (jotai_vanilla_store.INTERNAL_PrdStore & Partial<jotai_vanilla_store.INTERNAL_DevStoreRev2>) | null>;
    primaryEditorIds: string[];
}>>;
declare const plateControllerStore: jotai_x.StoreApi<{
    activeId: jotai.PrimitiveAtom<string | null> & {
        init: string | null;
    };
    editorStores: jotai.PrimitiveAtom<Record<string, (jotai_vanilla_store.INTERNAL_PrdStore & Partial<jotai_vanilla_store.INTERNAL_DevStoreRev2>) | null>> & {
        init: Record<string, (jotai_vanilla_store.INTERNAL_PrdStore & Partial<jotai_vanilla_store.INTERNAL_DevStoreRev2>) | null>;
    };
    primaryEditorIds: jotai.PrimitiveAtom<string[]> & {
        init: string[];
    };
}, object, "plateController">;
declare const usePlateControllerStore: jotai_x.UseStoreApi<{
    activeId: jotai.PrimitiveAtom<string | null> & {
        init: string | null;
    };
    editorStores: jotai.PrimitiveAtom<Record<string, (jotai_vanilla_store.INTERNAL_PrdStore & Partial<jotai_vanilla_store.INTERNAL_DevStoreRev2>) | null>> & {
        init: Record<string, (jotai_vanilla_store.INTERNAL_PrdStore & Partial<jotai_vanilla_store.INTERNAL_DevStoreRev2>) | null>;
    };
    primaryEditorIds: jotai.PrimitiveAtom<string[]> & {
        init: string[];
    };
}, object>;
declare const usePlateControllerSelectors: () => {
    activeId: (options?: (string | jotai_x.UseAtomOptions) | undefined) => string | null;
    editorStores: (options?: (string | jotai_x.UseAtomOptions) | undefined) => Record<string, (jotai_vanilla_store.INTERNAL_PrdStore & Partial<jotai_vanilla_store.INTERNAL_DevStoreRev2>) | null>;
    primaryEditorIds: (options?: (string | jotai_x.UseAtomOptions) | undefined) => string[];
} & {
    atom: <V>(atom: Atom<V>, options?: (string | jotai_x.UseAtomOptions) | undefined) => V;
};
declare const usePlateControllerActions: () => {
    activeId: (options?: (string | jotai_x.UseAtomOptions) | undefined) => (args_0: string | ((prev: string | null) => string | null) | null) => void;
    editorStores: (options?: (string | jotai_x.UseAtomOptions) | undefined) => (args_0: Record<string, (jotai_vanilla_store.INTERNAL_PrdStore & Partial<jotai_vanilla_store.INTERNAL_DevStoreRev2>) | null> | ((prev: Record<string, (jotai_vanilla_store.INTERNAL_PrdStore & Partial<jotai_vanilla_store.INTERNAL_DevStoreRev2>) | null>) => Record<string, (jotai_vanilla_store.INTERNAL_PrdStore & Partial<jotai_vanilla_store.INTERNAL_DevStoreRev2>) | null>)) => void;
    primaryEditorIds: (options?: (string | jotai_x.UseAtomOptions) | undefined) => (args_0: string[] | ((prev: string[]) => string[])) => void;
} & {
    atom: <V, A extends unknown[], R>(atom: jotai.WritableAtom<V, A, R>, options?: (string | jotai_x.UseAtomOptions) | undefined) => (...args: A) => R;
};
declare const usePlateControllerStates: () => {
    activeId: (options?: (string | jotai_x.UseAtomOptions) | undefined) => [string | null, (args_0: string | ((prev: string | null) => string | null) | null) => void];
    editorStores: (options?: (string | jotai_x.UseAtomOptions) | undefined) => [Record<string, (jotai_vanilla_store.INTERNAL_PrdStore & Partial<jotai_vanilla_store.INTERNAL_DevStoreRev2>) | null>, (args_0: Record<string, (jotai_vanilla_store.INTERNAL_PrdStore & Partial<jotai_vanilla_store.INTERNAL_DevStoreRev2>) | null> | ((prev: Record<string, (jotai_vanilla_store.INTERNAL_PrdStore & Partial<jotai_vanilla_store.INTERNAL_DevStoreRev2>) | null>) => Record<string, (jotai_vanilla_store.INTERNAL_PrdStore & Partial<jotai_vanilla_store.INTERNAL_DevStoreRev2>) | null>)) => void];
    primaryEditorIds: (options?: (string | jotai_x.UseAtomOptions) | undefined) => [string[], (args_0: string[] | ((prev: string[]) => string[])) => void];
} & {
    atom: <V, A extends unknown[], R>(atom: jotai.WritableAtom<V, A, R>, options?: (string | jotai_x.UseAtomOptions) | undefined) => [V, (...args: A) => R];
};
declare const usePlateControllerExists: () => boolean;
/**
 * Retrieve from PlateController the JotaiStore for the editor with a given ID,
 * or the active editor if no ID is provided, or the first primary editor if no
 * editor is active, or null.
 */
declare const usePlateControllerEditorStore: (idProp?: PlateId) => JotaiStore | null;

declare const EditorMethodsEffect: ({ id }: {
    id?: string | undefined;
}) => null;

declare function EditorRefPluginEffect({ id, plugin, }: {
    id?: PlateId;
    plugin: WithPlatePlugin;
}): null;
declare function EditorRefEffect({ id }: {
    id?: PlateId;
}): React__default.JSX.Element;

declare const EditorStateEffect: React__default.MemoExoticComponent<({ id }: {
    id?: string | undefined;
}) => null>;

type PlateContentProps = {
    /** Renders the editable content. */
    renderEditable?: (editable: React__default.ReactElement) => React__default.ReactNode;
} & TEditableProps;
/**
 * Editable with plugins.
 *
 * - Decorate prop
 * - DOM handler props
 * - ReadOnly prop
 * - RenderAfterEditable
 * - RenderBeforeEditable
 * - RenderElement prop
 * - RenderLeaf prop
 * - UseHooks
 */
declare const PlateContent: React__default.ForwardRefExoticComponent<{
    /** Renders the editable content. */
    renderEditable?: ((editable: React__default.ReactElement) => React__default.ReactNode) | undefined;
} & {
    decorate?: ((entry: _udecode_slate.TNodeEntry) => slate.BaseRange[]) | undefined;
    renderElement?: RenderElementFn | undefined;
    renderLeaf?: _udecode_slate_react.RenderLeafFn | undefined;
} & Omit<slate_react_dist_components_editable.EditableProps, "decorate" | "renderElement" | "renderLeaf"> & React__default.RefAttributes<unknown>>;

interface PlateControllerEffectProps {
    id?: string;
}
declare const PlateControllerEffect: ({ id: idProp, }: PlateControllerEffectProps) => null;

declare const useEditableProps: (editableProps?: TEditableProps) => TEditableProps;

type UsePlateEffectsProps<V extends Value = Value, E extends PlateEditor<V> = PlateEditor<V>> = Pick<PlateProps<V, E>, 'disableCorePlugins' | 'id' | 'plugins'>;
declare const usePlateEffects: <V extends Value = Value, E extends PlateEditor<V> = PlateEditor<V>>({ disableCorePlugins, id, plugins: pluginsProp, }: UsePlateEffectsProps<V, E>) => void;

/** Get Slate props stored in a global store. */
declare const useSlateProps: <V extends Value>({ id, }: {
    id?: string | undefined;
}) => Omit<SlateProps, 'children'>;

interface PlateEffectsProps<V extends Value = Value, E extends PlateEditor<V> = PlateEditor<V>> extends UsePlateEffectsProps<V, E> {
    children: React__default.ReactNode;
}
declare function PlateEffects<V extends Value = Value, E extends PlateEditor<V> = PlateEditor<V>>({ children, ...props }: PlateEffectsProps<V, E>): React__default.JSX.Element;

/**
 * Slate with plugins.
 *
 * - OnChange prop
 * - RenderAboveSlate
 */
declare function PlateSlate({ children, id, }: {
    children: React__default.ReactNode;
    id?: PlateId;
}): React__default.ReactElement<any, string | React__default.JSXElementConstructor<any>>;

declare function PlateTest<V extends Value>({ editableProps, normalizeInitialValue, variant, ...props }: {
    editableProps?: PlateContentProps;
    variant?: 'comment' | 'wordProcessor';
} & PlateProps<V>): React__default.JSX.Element;

declare const KEY_REACT = "react";
/** @see {@link withReact} */
declare const createReactPlugin: <OP = _udecode_utils.AnyObject, OV extends _udecode_slate.Value = _udecode_slate.Value, OE extends PlateEditor<OV> = PlateEditor<OV>>(override?: Partial<PlatePlugin<NoInfer<OP>, OV, OE>> | undefined, overrideByKey?: OverrideByKey<OV, OE>) => PlatePlugin<NoInfer<OP>, OV, OE>;

declare const withTReact: <V extends Value = Value, E extends PlateEditor<V> = PlateEditor<V>>(editor: E) => E;

declare const createPlateFallbackEditor: <V extends Value = Value, E extends TEditor<V> = TEditor<V>>(options?: CreatePlateEditorOptions<V, E>) => E & PlateEditor<V>;

declare const Hotkeys: {
    isTab: (editor: TReactEditor, event: React__default.KeyboardEvent, { composing, }?: {
        /** Ignore the event if composing. */
        composing?: boolean | undefined;
    }) => boolean;
    isUntab: (editor: TReactEditor, event: React__default.KeyboardEvent, { composing, }?: {
        /** Ignore the event if composing. */
        composing?: boolean | undefined;
    }) => boolean;
    isBold: (event: React__default.KeyboardEvent<Element>) => boolean;
    isCompose: (event: React__default.KeyboardEvent<Element>) => boolean;
    isDeleteBackward: (event: React__default.KeyboardEvent<Element>) => boolean;
    isDeleteForward: (event: React__default.KeyboardEvent<Element>) => boolean;
    isDeleteLineBackward: (event: React__default.KeyboardEvent<Element>) => boolean;
    isDeleteLineForward: (event: React__default.KeyboardEvent<Element>) => boolean;
    isDeleteWordBackward: (event: React__default.KeyboardEvent<Element>) => boolean;
    isDeleteWordForward: (event: React__default.KeyboardEvent<Element>) => boolean;
    isExtendBackward: (event: React__default.KeyboardEvent<Element>) => boolean;
    isExtendForward: (event: React__default.KeyboardEvent<Element>) => boolean;
    isExtendLineBackward: (event: React__default.KeyboardEvent<Element>) => boolean;
    isExtendLineForward: (event: React__default.KeyboardEvent<Element>) => boolean;
    isItalic: (event: React__default.KeyboardEvent<Element>) => boolean;
    isMoveBackward: (event: React__default.KeyboardEvent<Element>) => boolean;
    isMoveForward: (event: React__default.KeyboardEvent<Element>) => boolean;
    isMoveLineBackward: (event: React__default.KeyboardEvent<Element>) => boolean;
    isMoveLineForward: (event: React__default.KeyboardEvent<Element>) => boolean;
    isMoveWordBackward: (event: React__default.KeyboardEvent<Element>) => boolean;
    isMoveWordForward: (event: React__default.KeyboardEvent<Element>) => boolean;
    isRedo: (event: React__default.KeyboardEvent<Element>) => boolean;
    isSoftBreak: (event: React__default.KeyboardEvent<Element>) => boolean;
    isSplitBlock: (event: React__default.KeyboardEvent<Element>) => boolean;
    isTransposeCharacter: (event: React__default.KeyboardEvent<Element>) => boolean;
    isUndo: (event: React__default.KeyboardEvent<Element>) => boolean;
};

/** @see {@link RenderElement} */
declare const pipeRenderElement: <V extends Value>(editor: PlateEditor<V>, renderElementProp?: TEditableProps['renderElement']) => TEditableProps['renderElement'];

/** @see {@link RenderLeaf} */
declare const pipeRenderLeaf: <V extends Value>(editor: PlateEditor<V>, renderLeafProp?: TEditableProps['renderLeaf']) => TEditableProps['renderLeaf'];

/**
 * Get a `Editable.renderElement` handler for `options.type`. If the type is
 * equals to the slate element type, render `options.component`. Else, return
 * `undefined` so the pipeline can check the next plugin.
 */
declare const pluginRenderElement: <V extends Value>(editor: PlateEditor<V>, { component: _component, key, props, type }: PlatePlugin<{}, V>) => RenderElement;

/**
 * Get a `Editable.renderLeaf` handler for `options.type`. If the type is equals
 * to the slate leaf type, render `options.component`. Else, return `children`.
 */
declare const pluginRenderLeaf: <V extends Value>(editor: PlateEditor<V>, { component, key, props, type }: PlatePlugin<{}, V>) => RenderLeaf;

/** Flatten deep plugins then set editor.plugins and editor.pluginsByKey */
declare const setPlatePlugins: <V extends Value = Value, E extends PlateEditor<V> = PlateEditor<V>>(editor: E, { disableCorePlugins, maxLength, plugins: _plugins, }: Pick<PlateProps<V, E>, 'disableCorePlugins' | 'maxLength' | 'plugins'>) => void;

export { CreatePlateEditorOptions, EditorMethodsEffect, EditorRefEffect, EditorRefPluginEffect, EditorStateEffect, ElementProvider, type ElementStoreState, Hotkeys, KEY_REACT, NoInfer, OverrideByKey, PlateChangeKey, PlateContent, type PlateContentProps, PlateController, PlateControllerEffect, type PlateControllerEffectProps, PlateEditor, PlateEffects, type PlateEffectsProps, PlateId, PlatePlugin, PlateProps, PlateSlate, PlateTest, RenderElement, RenderElementFn, RenderLeaf, SCOPE_ELEMENT, TEditableProps, type UseEditorSelectorOptions, UsePlateEditorStoreOptions, type UsePlateEffectsProps, WithPlatePlugin, createPlateFallbackEditor, createReactPlugin, pipeRenderElement, pipeRenderLeaf, plateControllerStore, pluginRenderElement, pluginRenderLeaf, setPlatePlugins, useEditableProps, useEditorMounted, useEditorReadOnly, useEditorRef, useEditorSelection, useEditorSelector, useEditorState, useEditorVersion, useElement, useElementStore, useEventPlateId, useIncrementVersion, usePlateControllerActions, usePlateControllerEditorStore, usePlateControllerExists, usePlateControllerSelectors, usePlateControllerStates, usePlateControllerStore, usePlateEffects, useRedecorate, useReplaceEditor, useSelectionVersion, useSlateProps, withTReact };
