{"version":3,"sources":["../src/createTEditor.ts","../src/interfaces/editor/TEditor.ts","../src/interfaces/editor/addMark.ts","../src/interfaces/editor/createPathRef.ts","../src/interfaces/editor/createPointRef.ts","../src/interfaces/editor/createRangeRef.ts","../src/interfaces/editor/deleteBackward.ts","../src/interfaces/editor/deleteForward.ts","../src/interfaces/editor/deleteFragment.ts","../src/interfaces/editor/deleteMerge.ts","../src/interfaces/transforms/mergeNodes.ts","../src/interfaces/editor/getAboveNode.ts","../src/interfaces/editor/isBlock.ts","../src/interfaces/element/elementMatches.ts","../src/interfaces/element/isElement.ts","../src/interfaces/element/isElementList.ts","../src/utils/match.ts","../src/interfaces/editor/getNodeEntries.ts","../src/interfaces/editor/unhangRange.ts","../src/interfaces/editor/getParentNode.ts","../src/interfaces/editor/getPreviousNode.ts","../src/interfaces/editor/isElementEmpty.ts","../src/interfaces/editor/withoutNormalizing.ts","../src/interfaces/text/isText.ts","../src/interfaces/node/hasSingleChild.ts","../src/interfaces/transforms/deleteText.ts","../src/interfaces/transforms/moveNodes.ts","../src/interfaces/transforms/removeNodes.ts","../src/interfaces/transforms/select.ts","../src/interfaces/editor/getEndPoint.ts","../src/interfaces/editor/getLeafNode.ts","../src/interfaces/editor/getPointAfter.ts","../src/interfaces/editor/getPointBefore.ts","../src/interfaces/editor/getStartPoint.ts","../src/interfaces/editor/getVoidNode.ts","../src/interfaces/editor/isVoid.ts","../src/interfaces/editor/getEdgePoints.ts","../src/interfaces/editor/getEditorString.ts","../src/interfaces/editor/getFirstNode.ts","../src/interfaces/editor/getFragment.ts","../src/interfaces/editor/getLastNode.ts","../src/interfaces/editor/getLevels.ts","../src/interfaces/editor/getMarks.ts","../src/interfaces/editor/getNextNode.ts","../src/interfaces/editor/getNodeEntry.ts","../src/interfaces/editor/getPath.ts","../src/interfaces/editor/getPathRefs.ts","../src/interfaces/editor/getPoint.ts","../src/interfaces/editor/getPointRefs.ts","../src/interfaces/editor/getPositions.ts","../src/interfaces/editor/getRange.ts","../src/interfaces/editor/getRangeRefs.ts","../src/interfaces/editor/hasBlocks.ts","../src/interfaces/editor/hasInlines.ts","../src/interfaces/editor/hasTexts.ts","../src/interfaces/editor/insertBreak.ts","../src/interfaces/editor/insertNode.ts","../src/interfaces/editor/isEdgePoint.ts","../src/interfaces/editor/isEditor.ts","../src/interfaces/editor/isEditorNormalizing.ts","../src/interfaces/editor/isEndPoint.ts","../src/interfaces/editor/isInline.ts","../src/interfaces/editor/isMarkableVoid.ts","../src/interfaces/editor/isStartPoint.ts","../src/interfaces/editor/normalizeEditor.ts","../src/interfaces/editor/removeEditorMark.ts","../src/interfaces/history-editor/isHistoryEditor.ts","../src/interfaces/history-editor/isHistoryMerging.ts","../src/interfaces/history-editor/isHistorySaving.ts","../src/interfaces/history-editor/withoutMergingHistory.ts","../src/interfaces/history-editor/withoutSavingHistory.ts","../src/interfaces/node/TDescendant.ts","../src/interfaces/node/getCommonNode.ts","../src/interfaces/text/isTextList.ts","../src/interfaces/text/textEquals.ts","../src/interfaces/text/textMatches.ts","../src/interfaces/node/getNode.ts","../src/interfaces/node/getNodeAncestor.ts","../src/interfaces/node/getNodeAncestors.ts","../src/interfaces/node/getNodeChild.ts","../src/interfaces/node/getNodeChildren.ts","../src/interfaces/node/getNodeDescendant.ts","../src/interfaces/node/getNodeDescendants.ts","../src/interfaces/node/getNodeElements.ts","../src/interfaces/node/getNodeFirstNode.ts","../src/interfaces/node/getNodeFragment.ts","../src/interfaces/node/getNodeLastNode.ts","../src/interfaces/node/getNodeLeaf.ts","../src/interfaces/node/getNodeLevels.ts","../src/interfaces/node/getNodeParent.ts","../src/interfaces/node/getNodeProps.ts","../src/interfaces/node/getNodeString.ts","../src/interfaces/node/getNodeTexts.ts","../src/interfaces/node/getNodes.ts","../src/interfaces/node/hasNode.ts","../src/interfaces/node/isAncestor.ts","../src/interfaces/node/isNode.ts","../src/interfaces/node/isNodeList.ts","../src/interfaces/node/nodeMatches.ts","../src/interfaces/range/isCollapsed.ts","../src/interfaces/range/isExpanded.ts","../src/interfaces/transforms/collapseSelection.ts","../src/interfaces/transforms/deselect.ts","../src/interfaces/transforms/insertFragment.ts","../src/interfaces/transforms/insertNodes.ts","../src/utils/queryNode.ts","../src/interfaces/transforms/insertText.ts","../src/interfaces/transforms/liftNodes.ts","../src/interfaces/transforms/moveSelection.ts","../src/interfaces/transforms/setNodes.ts","../src/interfaces/transforms/setPoint.ts","../src/interfaces/transforms/setSelection.ts","../src/interfaces/transforms/splitNodes.ts","../src/interfaces/transforms/unsetNodes.ts","../src/interfaces/transforms/unwrapNodes.ts","../src/interfaces/transforms/wrapNodes.ts","../src/queries/findNode.ts","../src/queries/someNode.ts","../src/transforms/addRangeMarks.ts","../src/transforms/setElements.ts","../src/transforms/unhangCharacterRange.ts"],"sourcesContent":["import { createEditor } from 'slate';\n\nimport { TEditor, Value } from './interfaces/editor/TEditor';\n\nexport const createTEditor = <V extends Value>() =>\n  createEditor() as any as TEditor<V>;\n","import { Modify, UnknownObject } from '@udecode/utils';\nimport { Editor, Path } from 'slate';\n\nimport { TOperation } from '../../types/TOperation';\nimport { EElement, EElementOrText, TElement } from '../element/TElement';\nimport { TDescendant } from '../node/TDescendant';\nimport { ENode, TNode } from '../node/TNode';\nimport { TNodeEntry } from '../node/TNodeEntry';\n\nexport type Value = TElement[];\n\n/**\n * A helper type for getting the value of an editor.\n */\nexport type ValueOf<E extends TEditor> = E['children'];\n\nexport type TEditor<V extends Value = Value> = Modify<\n  Editor,\n  {\n    id: any;\n    children: V;\n    operations: TOperation[];\n    marks: Record<string, any> | null;\n\n    // Schema-specific node behaviors.\n    isInline: <N extends TElement>(element: N) => boolean;\n    isVoid: <N extends TElement>(element: N) => boolean;\n    markableVoid: <N extends TElement>(element: N) => boolean;\n    normalizeNode: <N extends TNode>(entry: TNodeEntry<N>) => void;\n\n    // Overrideable core actions.\n    apply: <N extends TDescendant>(operation: TOperation<N>) => void;\n    getFragment: <N extends TDescendant>() => N[];\n    insertFragment: <N extends TDescendant>(fragment: N[]) => void;\n    insertNode: <N extends TDescendant>(node: N) => void;\n    getDirtyPaths: <N extends TDescendant>(operation: TOperation<N>) => Path[];\n  }\n> &\n  UnknownObject;\n\n/**\n * Get editor with typed methods and operations.\n * Note that it can't be used as a parameter of type TEditor.\n */\nexport const getTEditor = <V extends Value, E extends TEditor<V> = TEditor<V>>(\n  editor: E\n) =>\n  editor as Modify<\n    E,\n    {\n      operations: TOperation<EElementOrText<V>>[];\n\n      // Schema-specific node behaviors.\n      isInline: (element: EElement<V>) => boolean;\n      isVoid: (element: EElement<V>) => boolean;\n      normalizeNode: (entry: TNodeEntry<ENode<V>>) => void;\n\n      // Overrideable core actions.\n      apply: (operation: TOperation<EElementOrText<V>>) => void;\n      getFragment: () => EElementOrText<V>[];\n      insertFragment: (fragment: EElementOrText<V>[]) => void;\n      insertNode: (node: EElementOrText<V> | EElementOrText<V>[]) => void;\n    }\n  >;\n","import { Editor } from 'slate';\n\nimport { TEditor, Value } from './TEditor';\n\n/**\n * Add a custom property to the leaf text nodes in the current selection.\n *\n * If the selection is currently collapsed, the marks will be added to the\n * `editor.marks` property instead, and applied when text is inserted next.\n */\nexport const addMark = <V extends Value>(\n  editor: TEditor<V>,\n  key: string,\n  value: any\n) => Editor.addMark(editor as any, key, value);\n","import { Editor, Path } from 'slate';\nimport { EditorPathRefOptions } from 'slate/dist/interfaces/editor';\n\nimport { TEditor, Value } from './TEditor';\n\n/**\n * Create a mutable ref for a `Path` object, which will stay in sync as new\n * operations are applied to the editor.\n */\nexport const createPathRef = <V extends Value>(\n  editor: TEditor<V>,\n  at: Path,\n  options?: EditorPathRefOptions\n) => Editor.pathRef(editor as any, at, options as any);\n","import { Editor, Point } from 'slate';\nimport { EditorPointRefOptions } from 'slate/dist/interfaces/editor';\n\nimport { TEditor, Value } from './TEditor';\n\n/**\n * Create a mutable ref for a `Point` object, which will stay in sync as new\n * operations are applied to the editor.\n */\nexport const createPointRef = <V extends Value>(\n  editor: TEditor<V>,\n  point: Point,\n  options?: EditorPointRefOptions\n) => Editor.pointRef(editor as any, point, options as any);\n","import { Editor, Range } from 'slate';\nimport { EditorRangeRefOptions } from 'slate/dist/interfaces/editor';\n\nimport { TEditor, Value } from './TEditor';\n\n/**\n * Create a mutable ref for a `Range` object, which will stay in sync as new\n * operations are applied to the editor.\n */\nexport const createRangeRef = <V extends Value>(\n  editor: TEditor<V>,\n  range: Range,\n  options?: EditorRangeRefOptions\n) => Editor.rangeRef(editor as any, range, options as any);\n","import { Editor } from 'slate';\nimport { EditorDirectedDeletionOptions } from 'slate/dist/interfaces/editor';\n\nimport { TEditor, Value } from './TEditor';\n\n/**\n * Delete content in the editor backward from the current selection.\n */\nexport const deleteBackward = <V extends Value>(\n  editor: TEditor<V>,\n  options?: EditorDirectedDeletionOptions\n) => Editor.deleteBackward(editor as any, options);\n","import { Editor } from 'slate';\nimport { EditorDirectedDeletionOptions } from 'slate/dist/interfaces/editor';\n\nimport { TEditor, Value } from './TEditor';\n\n/**\n * Delete content in the editor forward from the current selection.\n */\nexport const deleteForward = <V extends Value>(\n  editor: TEditor<V>,\n  options?: EditorDirectedDeletionOptions\n) => Editor.deleteForward(editor as any, options);\n","import { Editor } from 'slate';\nimport { EditorFragmentDeletionOptions } from 'slate/dist/interfaces/editor';\n\nimport { TEditor, Value } from './TEditor';\n\n/**\n * Delete the content in the current selection.\n */\nexport const deleteFragment = <V extends Value>(\n  editor: TEditor<V>,\n  options?: EditorFragmentDeletionOptions\n) => Editor.deleteFragment(editor as any, options);\n","import { Editor, Location, Path, Point, Range } from 'slate';\n\nimport { TNodeEntry } from '../node/TNodeEntry';\nimport { mergeNodes } from '../transforms/mergeNodes';\nimport { removeNodes } from '../transforms/removeNodes';\nimport { select } from '../transforms/select';\nimport { createPathRef } from './createPathRef';\nimport { createPointRef } from './createPointRef';\nimport { getAboveNode } from './getAboveNode';\nimport { getEndPoint } from './getEndPoint';\nimport { getLeafNode } from './getLeafNode';\nimport { getNodeEntries } from './getNodeEntries';\nimport { getPointAfter } from './getPointAfter';\nimport { getPointBefore } from './getPointBefore';\nimport { getStartPoint } from './getStartPoint';\nimport { getVoidNode } from './getVoidNode';\nimport { isBlock } from './isBlock';\nimport { isVoid } from './isVoid';\nimport { TEditor, Value } from './TEditor';\nimport { withoutNormalizing } from './withoutNormalizing';\n\nexport const deleteMerge = <V extends Value>(\n  editor: TEditor<V>,\n  options: {\n    at?: Location;\n    distance?: number;\n    unit?: 'character' | 'word' | 'line' | 'block';\n    reverse?: boolean;\n    hanging?: boolean;\n    voids?: boolean;\n    test?: any;\n  } = {}\n): void => {\n  withoutNormalizing(editor as any, () => {\n    const {\n      reverse = false,\n      unit = 'character',\n      distance = 1,\n      voids = false,\n    } = options;\n    let { at = editor.selection, hanging = false } = options;\n\n    if (!at) {\n      return;\n    }\n\n    if (Range.isRange(at) && Range.isCollapsed(at)) {\n      at = at.anchor;\n    }\n\n    if (Point.isPoint(at)) {\n      const furthestVoid = getVoidNode(editor as any, { at, mode: 'highest' });\n\n      if (!voids && furthestVoid) {\n        const [, voidPath] = furthestVoid;\n        at = voidPath;\n      } else {\n        const opts = { unit, distance };\n        const target = reverse\n          ? getPointBefore(editor as any, at, opts) ||\n            getStartPoint(editor as any, [])\n          : getPointAfter(editor as any, at, opts) ||\n            getEndPoint(editor as any, []);\n        at = { anchor: at, focus: target };\n        hanging = true;\n      }\n    }\n\n    if (Path.isPath(at)) {\n      removeNodes(editor, { at, voids });\n      return;\n    }\n\n    if (Range.isCollapsed(at)) {\n      return;\n    }\n\n    if (!hanging) {\n      at = Editor.unhangRange(editor as any, at, { voids });\n    }\n\n    let [start, end] = Range.edges(at);\n    const startBlock = getAboveNode(editor, {\n      match: (n) => isBlock(editor as any, n),\n      at: start,\n      voids,\n    });\n    const endBlock = getAboveNode(editor, {\n      match: (n) => isBlock(editor as any, n),\n      at: end,\n      voids,\n    });\n    const isAcrossBlocks =\n      startBlock && endBlock && !Path.equals(startBlock[1], endBlock[1]);\n    const isSingleText = Path.equals(start.path, end.path);\n    const startVoid = voids\n      ? null\n      : getVoidNode(editor as any, { at: start, mode: 'highest' });\n    const endVoid = voids\n      ? null\n      : getVoidNode(editor as any, { at: end, mode: 'highest' });\n\n    // If the start or end points are inside an inline void, nudge them out.\n    if (startVoid) {\n      const before = getPointBefore(editor as any, start);\n\n      if (before && startBlock && Path.isAncestor(startBlock[1], before.path)) {\n        start = before;\n      }\n    }\n\n    if (endVoid) {\n      const after = getPointAfter(editor as any, end);\n\n      if (after && endBlock && Path.isAncestor(endBlock[1], after.path)) {\n        end = after;\n      }\n    }\n\n    // Get the highest nodes that are completely inside the range, as well as\n    // the start and end nodes.\n    const matches: TNodeEntry[] = [];\n    let lastPath: Path | undefined;\n\n    const _nodes = getNodeEntries(editor as any, { at, voids });\n    for (const entry of _nodes) {\n      const [node, path] = entry;\n\n      if (lastPath && Path.compare(path, lastPath) === 0) {\n        continue;\n      }\n\n      if (\n        (!voids && isVoid(editor as any, node)) ||\n        (!Path.isCommon(path, start.path) && !Path.isCommon(path, end.path))\n      ) {\n        matches.push(entry as any);\n        lastPath = path;\n      }\n    }\n\n    const pathRefs = Array.from(matches, ([, p]) =>\n      createPathRef(editor as any, p)\n    );\n    const startRef = createPointRef(editor as any, start);\n    const endRef = createPointRef(editor as any, end);\n\n    if (!isSingleText && !startVoid) {\n      const point = startRef.current!;\n      const [node] = getLeafNode(editor as any, point);\n      const { path } = point;\n      const { offset } = start;\n      const text = node.text.slice(offset);\n      editor.apply({ type: 'remove_text', path, offset, text });\n    }\n\n    for (const pathRef of pathRefs) {\n      const path = pathRef.unref()!;\n      removeNodes(editor, { at: path, voids });\n    }\n\n    if (!endVoid) {\n      const point = endRef.current!;\n      const [node] = getLeafNode(editor as any, point);\n      const { path } = point;\n      const offset = isSingleText ? start.offset : 0;\n      const text = node.text.slice(offset, end.offset);\n      editor.apply({ type: 'remove_text', path, offset, text });\n    }\n\n    if (!isSingleText && isAcrossBlocks && endRef.current && startRef.current) {\n      // DIFF: allow custom mergeNodes\n      mergeNodes(editor as any, {\n        at: endRef.current,\n        hanging: true,\n        voids,\n      });\n    }\n\n    const point = endRef.unref() || startRef.unref();\n\n    if (options.at == null && point) {\n      select(editor as any, point);\n    }\n  });\n};\n","import { Modify } from '@udecode/utils';\nimport { Editor, Element, Path, Range, Text, Transforms } from 'slate';\n\nimport { NodeMatchOption } from '../../types/NodeMatchOption';\nimport { createPathRef } from '../editor/createPathRef';\nimport { createPointRef } from '../editor/createPointRef';\nimport { getAboveNode } from '../editor/getAboveNode';\nimport { getNodeEntries } from '../editor/getNodeEntries';\nimport { getParentNode } from '../editor/getParentNode';\nimport { getPreviousNode } from '../editor/getPreviousNode';\nimport { isBlock } from '../editor/isBlock';\nimport { isElementEmpty } from '../editor/isElementEmpty';\nimport { TEditor, Value } from '../editor/TEditor';\nimport { withoutNormalizing } from '../editor/withoutNormalizing';\nimport { isElement } from '../element/isElement';\nimport { hasSingleChild } from '../node/hasSingleChild';\nimport { isText } from '../text/isText';\nimport { deleteText } from './deleteText';\nimport { moveNodes } from './moveNodes';\nimport { removeNodes } from './removeNodes';\nimport { select } from './select';\n\nexport type MergeNodesOptions<V extends Value = Value> = Modify<\n  NonNullable<Parameters<typeof Transforms.mergeNodes>[1]>,\n  NodeMatchOption<V>\n> & {\n  /**\n   * Default: if the node isn't already the next sibling of the previous node, move\n   * it so that it is before merging.\n   */\n  mergeNode?: (editor: TEditor<V>, options: { at: Path; to: Path }) => void;\n\n  /**\n   * Default: if there was going to be an empty ancestor of the node that was merged,\n   * we remove it from the tree.\n   */\n  removeEmptyAncestor?: (editor: TEditor<V>, options: { at: Path }) => void;\n};\n\n/**\n * Merge a node at a location with the previous node of the same depth,\n * removing any empty containing nodes after the merge if necessary.\n */\nexport const mergeNodes = <V extends Value>(\n  editor: TEditor<V>,\n  options: MergeNodesOptions<V> = {}\n): void => {\n  withoutNormalizing(editor as any, () => {\n    let { match, at = editor.selection } = options;\n    const {\n      mergeNode,\n      removeEmptyAncestor,\n      hanging = false,\n      voids = false,\n      mode = 'lowest',\n    } = options;\n\n    if (!at) {\n      return;\n    }\n\n    if (match == null) {\n      if (Path.isPath(at)) {\n        const [parent] = getParentNode(editor, at)!;\n        match = (n) => parent.children.includes(n as any);\n      } else {\n        match = (n) => isBlock(editor as any, n);\n      }\n    }\n\n    if (!hanging && Range.isRange(at)) {\n      at = Editor.unhangRange(editor as any, at);\n    }\n\n    if (Range.isRange(at)) {\n      if (Range.isCollapsed(at)) {\n        at = at.anchor;\n      } else {\n        const [, end] = Range.edges(at);\n        const pointRef = createPointRef(editor as any, end);\n        deleteText(editor, { at });\n        at = pointRef.unref()!;\n\n        if (options.at == null) {\n          select(editor as any, at);\n        }\n      }\n    }\n\n    const _nodes = getNodeEntries(editor as any, { at, match, voids, mode });\n    const [current] = Array.from(_nodes);\n    const prev = getPreviousNode(editor as any, { at, match, voids, mode });\n\n    if (!current || !prev) {\n      return;\n    }\n\n    const [node, path] = current;\n    const [prevNode, prevPath] = prev;\n\n    if (path.length === 0 || prevPath.length === 0) {\n      return;\n    }\n\n    const newPath = Path.next(prevPath);\n    const commonPath = Path.common(path, prevPath);\n    const isPreviousSibling = Path.isSibling(path, prevPath);\n    const _levels = Editor.levels(editor as any, { at: path });\n    const levels = new Set(\n      Array.from(_levels, ([n]) => n)\n        .slice(commonPath.length)\n        .slice(0, -1)\n    );\n\n    // Determine if the merge will leave an ancestor of the path empty as a\n    // result, in which case we'll want to remove it after merging.\n    const emptyAncestor = getAboveNode(editor as any, {\n      at: path,\n      mode: 'highest',\n      match: (n) => levels.has(n) && isElement(n) && hasSingleChild(n),\n    });\n\n    const emptyRef =\n      emptyAncestor && createPathRef(editor as any, emptyAncestor[1]);\n    let properties;\n    let position;\n\n    // Ensure that the nodes are equivalent, and figure out what the position\n    // and extra properties of the merge will be.\n    if (isText(node) && isText(prevNode)) {\n      const { text, ...rest } = node;\n      position = prevNode.text.length;\n      properties = rest as Partial<Text>;\n    } else if (isElement(node) && isElement(prevNode)) {\n      const { children, ...rest } = node;\n      position = prevNode.children.length;\n      properties = rest as Partial<Element>;\n    } else {\n      throw new Error(\n        `Cannot merge the node at path [${path}] with the previous sibling because it is not the same kind: ${JSON.stringify(\n          node\n        )} ${JSON.stringify(prevNode)}`\n      );\n    }\n\n    // If the node isn't already the next sibling of the previous node, move\n    // it so that it is before merging.\n    if (\n      !isPreviousSibling && // DIFF\n      !mergeNode\n    ) {\n      moveNodes(editor, { at: path, to: newPath, voids });\n    }\n\n    // If there was going to be an empty ancestor of the node that was merged,\n    // we remove it from the tree.\n    if (emptyRef) {\n      // DIFF: start\n      if (removeEmptyAncestor) {\n        const emptyPath = emptyRef.current;\n        emptyPath && removeEmptyAncestor(editor as any, { at: emptyPath });\n      } else {\n        removeNodes(editor, { at: emptyRef.current!, voids });\n      }\n      // DIFF: end\n    }\n\n    // If the target node that we're merging with is empty, remove it instead\n    // of merging the two. This is a common rich text editor behavior to\n    // prevent losing formatting when deleting entire nodes when you have a\n    // hanging selection.\n    // DIFF: start\n    if (mergeNode) {\n      mergeNode(editor as any, { at: path, to: newPath });\n      // DIFF: end\n    } else if (\n      (isElement(prevNode) && isElementEmpty(editor as any, prevNode)) ||\n      (isText(prevNode) && prevNode.text === '')\n    ) {\n      removeNodes(editor, { at: prevPath, voids });\n    } else {\n      editor.apply({\n        type: 'merge_node',\n        path: newPath,\n        position,\n        properties,\n      });\n    }\n\n    if (emptyRef) {\n      emptyRef.unref();\n    }\n  });\n};\n","import { Modify } from '@udecode/utils';\nimport { Editor } from 'slate';\nimport { EditorAboveOptions } from 'slate/dist/interfaces/editor';\n\nimport { ENodeMatchOptions, getQueryOptions } from '../../utils/match';\nimport { EAncestor, TAncestor } from '../node/TAncestor';\nimport { TNodeEntry } from '../node/TNodeEntry';\nimport { TEditor, Value } from './TEditor';\n\nexport type GetAboveNodeOptions<V extends Value = Value> = Modify<\n  NonNullable<EditorAboveOptions<TAncestor>>,\n  ENodeMatchOptions<V>\n>;\n\n/**\n * Get the ancestor above a location in the document.\n */\nexport const getAboveNode = <N extends EAncestor<V>, V extends Value = Value>(\n  editor: TEditor<V>,\n  options?: GetAboveNodeOptions<V>\n): TNodeEntry<N> | undefined =>\n  Editor.above(editor as any, getQueryOptions(editor, options)) as any;\n","import { Editor } from 'slate';\n\nimport { isElement } from '../element';\nimport { TEditor, Value } from './TEditor';\n\n/**\n * Check if a value is a block `Element` object.\n */\nexport const isBlock = <V extends Value>(\n  editor: TEditor<V>,\n  value: any\n): boolean => isElement(value) && Editor.isBlock(editor as any, value);\n","import { Element } from 'slate';\n\nimport { TElement } from './TElement';\n\n/**\n * Check if an element matches set of properties.\n *\n * Note: this checks custom properties, and it does not ensure that any\n * children are equivalent.\n */\nexport const elementMatches = (element: TElement, props: object) =>\n  Element.matches(element, props);\n","import { Element } from 'slate';\n\nimport { TElement } from './TElement';\n\n/**\n * Check if a value implements the 'Element' interface.\n */\nexport const isElement = (value: any): value is TElement =>\n  Element.isElement(value);\n","import { Element } from 'slate';\n\nimport { TElement } from './TElement';\n\n/**\n * Check if a value is an array of `Element` objects.\n */\nexport const isElementList = (value: any): value is TElement[] =>\n  Element.isElementList(value);\n","import { isBlock } from '../interfaces/editor/isBlock';\nimport { TEditor, Value } from '../interfaces/editor/TEditor';\nimport { ENode, TNode } from '../interfaces/node/TNode';\nimport { TPath } from '../types/interfaces';\n\nexport type PredicateObj = Record<string, any | any[]>;\nexport type PredicateFn<T extends TNode> = (obj: T, path: TPath) => boolean;\nexport type Predicate<T extends TNode> = PredicateObj | PredicateFn<T>;\n\nfunction castArray<T>(value: T | T[]): T[] {\n  return Array.isArray(value) ? value : [value];\n}\n\n/**\n * Match the object with a predicate object or function.\n * If predicate is:\n * - object: every predicate key/value should be in obj.\n * - function: it should return true.\n */\nexport const match = <T extends TNode>(\n  obj: T,\n  path: TPath,\n  predicate?: Predicate<T>\n): boolean => {\n  if (!predicate) return true;\n\n  if (typeof predicate === 'object') {\n    return Object.entries(predicate).every(([key, value]) => {\n      const values = castArray<any>(value);\n\n      return values.includes(obj[key]);\n    });\n  }\n\n  return predicate(obj, path);\n};\n\n/**\n * Extended query options for slate queries:\n * - `match` can be an object predicate where one of the values should include the node value.\n * Example: { type: ['1', '2'] } will match the nodes having one of these 2 types.\n */\nexport const getQueryOptions = <V extends Value>(\n  editor: TEditor<V>,\n  options: any = {}\n) => {\n  const { match: _match, block } = options;\n\n  return {\n    ...options,\n    match:\n      _match || block\n        ? (n: ENode<V>, path: TPath) =>\n            match(n, path, _match) && (!block || isBlock(editor, n))\n        : undefined,\n  };\n};\n\nexport type ENodeMatch<N extends TNode> = Predicate<N>;\n\nexport interface ENodeMatchOptions<V extends Value = Value> {\n  match?: ENodeMatch<ENode<V>>;\n  block?: boolean;\n}\n","import { Modify } from '@udecode/utils';\nimport { Editor, EditorNodesOptions } from 'slate';\n\nimport { ENodeMatchOptions, getQueryOptions } from '../../utils/match';\nimport { ENode, TNode } from '../node/TNode';\nimport { TNodeEntry } from '../node/TNodeEntry';\nimport { TEditor, Value } from './TEditor';\nimport { unhangRange, UnhangRangeOptions } from './unhangRange';\n\nexport type GetNodeEntriesOptions<V extends Value = Value> = Modify<\n  NonNullable<EditorNodesOptions<TNode>>,\n  ENodeMatchOptions<V>\n> &\n  UnhangRangeOptions;\n\n/**\n * Iterate through all of the nodes in the Editor.\n */\nexport const getNodeEntries = <N extends ENode<V>, V extends Value = Value>(\n  editor: TEditor<V>,\n  options?: GetNodeEntriesOptions<V>\n): Generator<TNodeEntry<N>, void, undefined> => {\n  unhangRange(editor, options?.at, options);\n\n  return Editor.nodes(editor as any, getQueryOptions(editor, options)) as any;\n};\n","import {\n  Editor,\n  EditorUnhangRangeOptions,\n  Path,\n  Point,\n  Range,\n  Span,\n} from 'slate';\n\nimport { TEditor, Value } from './TEditor';\n\nexport type UnhangRangeOptions = EditorUnhangRangeOptions & {\n  unhang?: boolean;\n};\n\n/**\n * Convert a range into a non-hanging one if:\n * - `unhang` is true,\n * - `at` (default: selection) is a range.\n */\nexport const unhangRange = <\n  V extends Value,\n  R extends Range | Path | Point | Span | null | undefined,\n>(\n  editor: TEditor<V>,\n  range: R,\n  options: UnhangRangeOptions = {}\n): R => {\n  const { voids, unhang = true } = options;\n\n  if (Range.isRange(range) && unhang) {\n    return Editor.unhangRange(editor as any, range, { voids }) as R;\n  }\n\n  return range;\n};\n","import { Editor, EditorParentOptions, Location } from 'slate';\n\nimport { EAncestor } from '../node/TAncestor';\nimport { TNodeEntry } from '../node/TNodeEntry';\nimport { TEditor, Value } from './TEditor';\n\n/**\n * Get the parent node of a location.\n * Returns undefined if there is no parent.\n */\nexport const getParentNode = <N extends EAncestor<V>, V extends Value = Value>(\n  editor: TEditor<V>,\n  at: Location,\n  options?: EditorParentOptions\n): TNodeEntry<N> | undefined => {\n  try {\n    return Editor.parent(editor as any, at, options) as any;\n  } catch (error) {}\n};\n","import { Modify } from '@udecode/utils';\nimport { Editor, EditorPreviousOptions } from 'slate';\n\nimport { ENode, TNode, TNodeMatch } from '../node/TNode';\nimport { TNodeEntry } from '../node/TNodeEntry';\nimport { TEditor, Value } from './TEditor';\n\nexport type GetPreviousNodeOptions<V extends Value = Value> = Modify<\n  NonNullable<EditorPreviousOptions<TNode>>,\n  {\n    match?: TNodeMatch<ENode<V>>;\n  }\n>;\n\n/**\n * Get the matching node in the branch of the document before a location.\n */\nexport const getPreviousNode = <N extends ENode<V>, V extends Value = Value>(\n  editor: TEditor<V>,\n  options?: GetPreviousNodeOptions<V>\n): TNodeEntry<N> | undefined =>\n  Editor.previous(editor as any, options as any) as any;\n","import { Editor } from 'slate';\n\nimport { EElement } from '../element/TElement';\nimport { TEditor, Value } from './TEditor';\n\n/**\n * Check if an element is empty, accounting for void nodes.\n */\nexport const isElementEmpty = <V extends Value>(\n  editor: TEditor<V>,\n  element: EElement<V>\n) => Editor.isEmpty(editor as any, element);\n","import { Editor } from 'slate';\n\nimport { TEditor, Value } from './TEditor';\n\n/**\n * Call a function, deferring normalization until after it completes\n * @return true if normalized.\n */\nexport const withoutNormalizing = <V extends Value>(\n  editor: TEditor<V>,\n  fn: () => boolean | void\n) => {\n  let normalized = false;\n\n  Editor.withoutNormalizing(editor as any, () => {\n    normalized = !!fn();\n  });\n\n  return normalized;\n};\n","import { Text } from 'slate';\n\nimport { TText } from './TText';\n\n/**\n * Check if a value implements the `Text` interface.\n */\nexport const isText = (value: any): value is TText => Text.isText(value);\n","import { isText } from '../text/isText';\nimport { TNode } from './TNode';\n\nexport const hasSingleChild = <N extends TNode>(node: N): boolean => {\n  if (isText(node)) {\n    return true;\n  }\n  return node.children.length === 1 && hasSingleChild(node.children[0]);\n};\n","import { Transforms } from 'slate';\nimport { TextDeleteOptions } from 'slate/dist/interfaces/transforms/text';\n\nimport { TEditor, Value } from '../editor/TEditor';\n\n/**\n * Delete content in the editor.\n */\nexport const deleteText = <V extends Value>(\n  editor: TEditor<V>,\n  options?: TextDeleteOptions\n) => {\n  Transforms.delete(editor as any, options);\n};\n","import { Modify } from '@udecode/utils';\nimport { Transforms } from 'slate';\n\nimport { NodeMatchOption } from '../../types/NodeMatchOption';\nimport { TEditor, Value } from '../editor/TEditor';\n\nexport type MoveNodesOptions<V extends Value = Value> = Modify<\n  NonNullable<Parameters<typeof Transforms.moveNodes>[1]>,\n  NodeMatchOption<V>\n>;\n\n/**\n * Move the nodes at a location to a new location.\n */\nexport const moveNodes = <V extends Value>(\n  editor: TEditor<V>,\n  options?: MoveNodesOptions<V>\n) => Transforms.moveNodes(editor as any, options as any);\n","import { Modify } from '@udecode/utils';\nimport { Transforms } from 'slate';\n\nimport { NodeMatchOption } from '../../types/NodeMatchOption';\nimport { TEditor, Value } from '../editor/TEditor';\n\nexport type RemoveNodesOptions<V extends Value = Value> = Modify<\n  NonNullable<Parameters<typeof Transforms.removeNodes>[1]>,\n  NodeMatchOption<V>\n>;\n\n/**\n * Remove the nodes at a specific location in the document.\n */\nexport const removeNodes = <V extends Value>(\n  editor: TEditor<V>,\n  options?: RemoveNodesOptions<V>\n) => Transforms.removeNodes(editor as any, options as any);\n","import { Location, Transforms } from 'slate';\n\nimport { TEditor, Value } from '../editor/TEditor';\n\n/**\n * Set the selection to a new value.\n */\nexport const select = <V extends Value>(\n  editor: TEditor<V>,\n  target: Location\n) => {\n  Transforms.select(editor as any, target);\n};\n","import { Editor, Location } from 'slate';\n\nimport { TEditor, Value } from './TEditor';\n\n/**\n * Get the end point of a location.\n */\nexport const getEndPoint = <V extends Value>(\n  editor: TEditor<V>,\n  at: Location\n) => Editor.end(editor as any, at);\n","import { Editor, Location } from 'slate';\nimport { EditorLeafOptions } from 'slate/dist/interfaces/editor';\n\nimport { ETextEntry } from '../node/TNodeEntry';\nimport { TEditor, Value } from './TEditor';\n\n/**\n * Get the leaf text node at a location.\n */\nexport const getLeafNode = <V extends Value>(\n  editor: TEditor<V>,\n  at: Location,\n  options?: EditorLeafOptions\n): ETextEntry<V> => Editor.leaf(editor as any, at, options) as any;\n","import { Editor, EditorAfterOptions, Location } from 'slate';\n\nimport { TEditor, Value } from './TEditor';\n\n/**\n * Get the point after a location.\n */\nexport const getPointAfter = <V extends Value>(\n  editor: TEditor<V>,\n  at: Location,\n  options?: EditorAfterOptions\n) => Editor.after(editor as any, at, options);\n","import { Editor, EditorBeforeOptions, Location } from 'slate';\n\nimport { TEditor, Value } from './TEditor';\n\n/**\n * Get the point before a location.\n */\nexport const getPointBefore = <V extends Value>(\n  editor: TEditor<V>,\n  at: Location,\n  options?: EditorBeforeOptions\n) => Editor.before(editor as any, at, options);\n","import { Editor, Location } from 'slate';\n\nimport { TEditor, Value } from './TEditor';\n\n/**\n * Get the start point of a location.\n */\nexport const getStartPoint = <V extends Value>(\n  editor: TEditor<V>,\n  at: Location\n) => Editor.start(editor as any, at);\n","import { Editor, EditorVoidOptions } from 'slate';\n\nimport { EElement } from '../element/TElement';\nimport { TNodeEntry } from '../node/TNodeEntry';\nimport { TEditor, Value } from './TEditor';\n\n/**\n * Match a void node in the current branch of the editor.\n */\nexport const getVoidNode = <N extends EElement<V>, V extends Value = Value>(\n  editor: TEditor<V>,\n  options?: EditorVoidOptions\n): TNodeEntry<N> | undefined => Editor.void(editor as any, options) as any;\n","import { Editor } from 'slate';\n\nimport { isElement } from '../element';\nimport { TEditor, Value } from './TEditor';\n\n/**\n * Check if a value is a void `Element` object.\n */\nexport const isVoid = <V extends Value>(\n  editor: TEditor<V>,\n  value: any\n): boolean => {\n  return isElement(value) && Editor.isVoid(editor as any, value);\n};\n","import { Editor, Location } from 'slate';\n\nimport { TEditor, Value } from './TEditor';\n\n/**\n * Get the start and end points of a location.\n */\nexport const getEdgePoints = <V extends Value>(\n  editor: TEditor<V>,\n  at: Location\n) => Editor.edges(editor as any, at);\n","import { Editor, Location } from 'slate';\nimport { EditorStringOptions } from 'slate/dist/interfaces/editor';\n\nimport { TEditor, Value } from './TEditor';\n\n/**\n * Get the text string content of a location.\n *\n * Note: by default the text of void nodes is considered to be an empty\n * string, regardless of content, unless you pass in true for the voids option\n */\nexport const getEditorString = <V extends Value>(\n  editor: TEditor<V>,\n  at: Location | null | undefined,\n  options?: EditorStringOptions\n) => {\n  if (!at) return '';\n\n  try {\n    return Editor.string(editor as any, at, options);\n  } catch (error) {\n    return '';\n  }\n};\n","import { Editor, Location } from 'slate';\n\nimport { ENodeEntry } from '../node/TNodeEntry';\nimport { TEditor, Value } from './TEditor';\n\n/**\n * Get the first node at a location.\n */\nexport const getFirstNode = <V extends Value>(\n  editor: TEditor<V>,\n  at: Location\n): ENodeEntry<V> => Editor.first(editor as any, at) as any;\n","import { Editor, Location } from 'slate';\n\nimport { EElementOrText } from '../element/TElement';\nimport { TEditor, Value } from './TEditor';\n\n/**\n * Get the fragment at a location.\n */\nexport const getFragment = <V extends Value>(\n  editor: TEditor<V>,\n  at: Location\n): EElementOrText<V>[] => Editor.fragment(editor as any, at) as any;\n","import { Editor, Location } from 'slate';\n\nimport { ENodeEntry } from '../node/TNodeEntry';\nimport { TEditor, Value } from './TEditor';\n\n/**\n * Get the last node at a location.\n */\nexport const getLastNode = <V extends Value>(\n  editor: TEditor<V>,\n  at: Location\n): ENodeEntry<V> => Editor.last(editor as any, at) as any;\n","import { Modify } from '@udecode/utils';\nimport { Editor, EditorLevelsOptions } from 'slate';\n\nimport { ENode, TNode, TNodeMatch } from '../node/TNode';\nimport { TNodeEntry } from '../node/TNodeEntry';\nimport { TEditor, Value } from './TEditor';\n\nexport type GetLevelsOptions<V extends Value = Value> = Modify<\n  NonNullable<EditorLevelsOptions<TNode>>,\n  {\n    match?: TNodeMatch<ENode<V>>;\n  }\n>;\n\n/**\n * Iterate through all of the levels at a location.\n */\nexport const getLevels = <N extends ENode<V>, V extends Value = Value>(\n  editor: TEditor<V>,\n  options?: GetLevelsOptions<V>\n): Generator<TNodeEntry<N>, void, undefined> =>\n  Editor.levels(editor as any, options as any) as any;\n","import { Editor } from 'slate';\n\nimport { EMarks } from '../text/TText';\nimport { TEditor, Value } from './TEditor';\n\n/**\n * Get the marks that would be added to text at the current selection.\n */\nexport const getMarks = <V extends Value>(editor: TEditor<V>) =>\n  Editor.marks(editor as any) as EMarks<V> | null;\n","import { Modify } from '@udecode/utils';\nimport { Editor, EditorNextOptions } from 'slate';\n\nimport { TDescendant } from '../node';\nimport { ENode, TNodeMatch } from '../node/TNode';\nimport { TNodeEntry } from '../node/TNodeEntry';\nimport { TEditor, Value } from './TEditor';\n\nexport type GetNextNodeOptions<V extends Value = Value> = Modify<\n  NonNullable<EditorNextOptions<TDescendant>>,\n  {\n    match?: TNodeMatch<ENode<V>>;\n  }\n>;\n\n/**\n * Get the matching node in the branch of the document after a location.\n */\nexport const getNextNode = <N extends ENode<V>, V extends Value = Value>(\n  editor: TEditor<V>,\n  options?: GetNextNodeOptions<V>\n): TNodeEntry<N> | undefined =>\n  Editor.next(editor as any, options as any) as any;\n","import { Editor, EditorNodeOptions, Location } from 'slate';\n\nimport { ENode } from '../node/TNode';\nimport { TNodeEntry } from '../node/TNodeEntry';\nimport { TEditor, Value } from './TEditor';\n\n/**\n * Get the node at a location.\n */\nexport const getNodeEntry = <N extends ENode<V>, V extends Value = Value>(\n  editor: TEditor<V>,\n  at: Location,\n  options?: EditorNodeOptions\n): TNodeEntry<N> | undefined => {\n  try {\n    return Editor.node(editor as any, at, options) as any;\n  } catch (error) {}\n};\n","import { Editor, EditorPathOptions, Location } from 'slate';\n\nimport { TEditor, Value } from './TEditor';\n\n/**\n * Get the path of a location.\n */\nexport const getPath = <V extends Value>(\n  editor: TEditor<V>,\n  at: Location,\n  options?: EditorPathOptions\n) => Editor.path(editor as any, at, options as any);\n","import { Editor } from 'slate';\n\nimport { TEditor, Value } from './TEditor';\n\n/**\n * Get the set of currently tracked path refs of the editor.\n */\nexport const getPathRefs = <V extends Value>(editor: TEditor<V>) =>\n  Editor.pathRefs(editor as any);\n","import { Editor, EditorPointOptions, Location } from 'slate';\n\nimport { TEditor, Value } from './TEditor';\n\n/**\n * Get the start or end point of a location.\n */\nexport const getPoint = <V extends Value>(\n  editor: TEditor<V>,\n  at: Location,\n  options?: EditorPointOptions\n) => Editor.point(editor as any, at, options);\n","import { Editor } from 'slate';\n\nimport { TEditor, Value } from './TEditor';\n\n/**\n * Get the set of currently tracked point refs of the editor.\n */\nexport const getPointRefs = <V extends Value>(editor: TEditor<V>) =>\n  Editor.pointRefs(editor as any);\n","import { Editor, EditorPositionsOptions } from 'slate';\n\nimport { TEditor, Value } from './TEditor';\n\n/**\n * Iterate through all of the positions in the document where a `Point` can be\n * placed.\n *\n * By default it will move forward by individual offsets at a time,  but you\n * can pass the `unit: 'character'` option to moved forward one character, word,\n * or line at at time.\n *\n * Note: By default void nodes are treated as a single point and iteration\n * will not happen inside their content unless you pass in true for the\n * voids option, then iteration will occur.\n */\nexport const getPositions = <V extends Value>(\n  editor: TEditor<V>,\n  options?: EditorPositionsOptions\n) => Editor.positions(editor as any, options);\n","import { Editor, Location } from 'slate';\n\nimport { TEditor, Value } from './TEditor';\n\n/**\n * Get a range of a location.\n */\nexport const getRange = <V extends Value>(\n  editor: TEditor<V>,\n  at: Location,\n  to?: Location\n) => Editor.range(editor as any, at, to);\n","import { Editor } from 'slate';\n\nimport { TEditor, Value } from './TEditor';\n\n/**\n * Get the set of currently tracked range refs of the editor.\n */\nexport const getRangeRefs = <V extends Value>(editor: TEditor<V>) =>\n  Editor.rangeRefs(editor as any);\n","import { Editor } from 'slate';\n\nimport { TElement } from '../element/TElement';\nimport { TEditor, Value } from './TEditor';\n\n/**\n * Check if a node has block children.\n */\nexport const hasBlocks = <V extends Value>(\n  editor: TEditor<V>,\n  element: TElement\n) => Editor.hasBlocks(editor as any, element);\n","import { Editor } from 'slate';\n\nimport { TElement } from '../element/TElement';\nimport { TEditor, Value } from './TEditor';\n\n/**\n * Check if a node has inline and text children.\n */\nexport const hasInlines = <V extends Value>(\n  editor: TEditor<V>,\n  element: TElement\n) => Editor.hasInlines(editor as any, element);\n","import { Editor } from 'slate';\n\nimport { TElement } from '../element/TElement';\nimport { TEditor, Value } from './TEditor';\n\n/**\n * Check if a node has text children.\n */\nexport const hasTexts = <V extends Value>(\n  editor: TEditor<V>,\n  element: TElement\n) => Editor.hasTexts(editor as any, element);\n","import { Editor } from 'slate';\n\nimport { TEditor, Value } from './TEditor';\n\n/**\n * Insert a block break at the current selection.\n *\n * If the selection is currently expanded, it will be deleted first.\n */\nexport const insertBreak = <V extends Value>(editor: TEditor<V>) =>\n  Editor.insertBreak(editor as any);\n","import { Editor } from 'slate';\n\nimport { EElementOrText } from '../element/TElement';\nimport { TEditor, Value } from './TEditor';\n\n/**\n * Insert a node at the current selection.\n *\n * If the selection is currently expanded, it will be deleted first.\n */\nexport const insertNode = <V extends Value>(\n  editor: TEditor<V>,\n  node: EElementOrText<V> | EElementOrText<V>[]\n) => Editor.insertNode(editor as any, node as any);\n","import { Editor, Location, Point } from 'slate';\n\nimport { TEditor, Value } from './TEditor';\n\n/**\n * Check if a point is an edge of a location.\n */\nexport const isEdgePoint = <V extends Value>(\n  editor: TEditor<V>,\n  point: Point,\n  at: Location\n) => Editor.isEdge(editor as any, point, at);\n","import { Editor } from 'slate';\n\nimport { TEditor } from './TEditor';\n\n/**\n * Check if a value is an `Editor` object.\n */\nexport const isEditor = (value: any): value is TEditor =>\n  Editor.isEditor(value);\n","import { Editor } from 'slate';\n\nimport { TEditor, Value } from './TEditor';\n\n/**\n * Check if the editor is currently normalizing after each operation.\n */\nexport const isEditorNormalizing = <V extends Value>(editor: TEditor<V>) =>\n  Editor.isNormalizing(editor as any);\n","import { Editor, Location, Point } from 'slate';\n\nimport { TEditor, Value } from './TEditor';\n\n/**\n * Check if a point is the end point of a location.\n * If point is null, return false.\n */\nexport const isEndPoint = <V extends Value>(\n  editor: TEditor<V>,\n  point: Point | null | undefined,\n  at: Location\n) => !!point && Editor.isEnd(editor as any, point, at);\n","import { Editor } from 'slate';\n\nimport { isElement } from '../element';\nimport { TEditor, Value } from './TEditor';\n\n/**\n * Check if a value is an inline `Element` object.\n */\nexport const isInline = <V extends Value>(\n  editor: TEditor<V>,\n  value: any\n): boolean => isElement(value) && Editor.isInline(editor as any, value);\n","import { isElement } from '../element';\nimport { TEditor, Value } from './TEditor';\n\n/**\n * Check if a value is a markable void `Element` object.\n */\nexport const isMarkableVoid = <V extends Value>(\n  editor: TEditor<V>,\n  value: any\n): boolean => {\n  return isElement(value) && editor.markableVoid(value);\n};\n","import { Editor, Location, Point } from 'slate';\n\nimport { TEditor, Value } from './TEditor';\n\n/**\n * Check if a point is the start point of a location.\n * If point is null, return false.\n */\nexport const isStartPoint = <V extends Value>(\n  editor: TEditor<V>,\n  point: Point | null | undefined,\n  at: Location\n) => !!point && Editor.isStart(editor as any, point, at);\n","import { Editor, EditorNormalizeOptions } from 'slate';\n\nimport { TEditor, Value } from './TEditor';\n\n/**\n * Normalize any dirty objects in the editor.\n */\nexport const normalizeEditor = <V extends Value>(\n  editor: TEditor<V>,\n  options?: EditorNormalizeOptions\n) => Editor.normalize(editor as any, options);\n","import { Editor } from 'slate';\n\nimport { TEditor, Value } from './TEditor';\n\n/**\n * Remove a custom property from all of the leaf text nodes in the current\n * selection.\n *\n * If the selection is currently collapsed, the removal will be stored on\n * `editor.marks` and applied to the text inserted next.\n */\nexport const removeEditorMark = <V extends Value>(\n  editor: TEditor<V>,\n  key: string\n) => Editor.removeMark(editor as any, key);\n","import { HistoryEditor } from 'slate-history';\n\nimport { THistoryEditor } from './THistoryEditor';\n\n/**\n * {@link HistoryEditor.isHistoryEditor}\n */\nexport const isHistoryEditor = (value: any): value is THistoryEditor =>\n  HistoryEditor.isHistoryEditor(value as any);\n","import { HistoryEditor } from 'slate-history';\n\nimport { Value } from '../editor/TEditor';\nimport { THistoryEditor } from './THistoryEditor';\n\n/**\n * {@link HistoryEditor.isMerging}\n */\nexport const isHistoryMerging = <V extends Value>(editor: THistoryEditor<V>) =>\n  HistoryEditor.isMerging(editor as any);\n","import { HistoryEditor } from 'slate-history';\n\nimport { Value } from '../editor/TEditor';\nimport { THistoryEditor } from './THistoryEditor';\n\n/**\n * {@link HistoryEditor.isSaving}\n */\nexport const isHistorySaving = <V extends Value>(editor: THistoryEditor<V>) =>\n  HistoryEditor.isSaving(editor as any);\n","import { HistoryEditor } from 'slate-history';\n\nimport { Value } from '../editor/TEditor';\nimport { THistoryEditor } from './THistoryEditor';\n\n/**\n * {@link HistoryEditor.withoutMerging}\n */\nexport const withoutMergingHistory = <V extends Value>(\n  editor: THistoryEditor<V>,\n  fn: () => void\n) => HistoryEditor.withoutMerging(editor as any, fn);\n","import { HistoryEditor } from 'slate-history';\n\nimport { Value } from '../editor/TEditor';\nimport { THistoryEditor } from './THistoryEditor';\n\n/**\n * {@link HistoryEditor.withoutSaving}\n */\nexport const withoutSavingHistory = <V extends Value>(\n  editor: THistoryEditor<V>,\n  fn: () => void\n) => HistoryEditor.withoutSaving(editor as any, fn);\n","import { TEditor, Value } from '../editor/TEditor';\nimport { isElement } from '../element/isElement';\nimport { ElementOf, TElement } from '../element/TElement';\nimport { isText } from '../text/isText';\nimport { TextOf, TText } from '../text/TText';\nimport { TNode } from './TNode';\n\n/**\n * The `Descendant` union type represents nodes that are descendants in the\n * tree. It is returned as a convenience in certain cases to narrow a value\n * further than the more generic `Node` union.\n */\nexport type TDescendant = TElement | TText;\n\n/**\n * Descendant of an editor.\n */\nexport type EDescendant<V extends Value> = DescendantOf<TEditor<V>>;\n\n/**\n * A utility type to get all the descendant node types from a root node type.\n */\nexport type DescendantOf<N extends TNode> = N extends TEditor\n  ? ElementOf<N> | TextOf<N>\n  : N extends TElement\n  ? ElementOf<N['children'][number]> | TextOf<N>\n  : never;\n\n/**\n * A utility type to get the child node types from a root node type.\n */\nexport type ChildOf<\n  N extends TNode,\n  I extends number = number,\n> = N extends TEditor\n  ? N['children'][I]\n  : N extends TElement\n  ? N['children'][I]\n  : never;\n\nexport const isDescendant: (value: any) => value is TDescendant = ((\n  node: any\n) => isElement(node) || isText(node)) as any;\n","import { Node, Path } from 'slate';\n\nimport { NodeOf, TNode } from './TNode';\nimport { TNodeEntry } from './TNodeEntry';\n\n/**\n * Get an entry for the common ancesetor node of two paths.\n */\nexport const getCommonNode = <N extends NodeOf<R>, R extends TNode = TNode>(\n  root: R,\n  path: Path,\n  another: Path\n) => Node.common(root, path, another) as TNodeEntry<N>;\n","import { Text } from 'slate';\n\nimport { TText } from './TText';\n\n/**\n * Check if a value is a list of `Text` objects.\n */\nexport const isTextList = (value: any): value is TText[] =>\n  Text.isTextList(value);\n","import { Text } from 'slate';\n\nimport { TText } from './TText';\n\n/**\n * Check if two text nodes are equal.\n */\nexport const textEquals = (text: TText, another: TText) =>\n  Text.equals(text, another);\n","import { Text } from 'slate';\n\nimport { TText } from './TText';\n\n/**\n * Check if an text matches set of properties.\n *\n * Note: this is for matching custom properties, and it does not ensure that\n * the `text` property are two nodes equal.\n */\nexport const textMatches = <T extends TText>(text: T, props: object) =>\n  Text.matches(text, props);\n","import { Path } from 'slate';\n\nimport { isText } from '../text';\nimport { NodeOf, TNode } from './TNode';\n\n/**\n * Get the descendant node referred to by a specific path.\n * If the path is an empty array, it refers to the root node itself.\n * If the node is not found, return null.\n * Based on Slate get and has, performance optimization without overhead of\n * stringify on throwing\n */\nexport const getNode = <N extends NodeOf<R>, R extends TNode = TNode>(\n  root: R,\n  path: Path\n) => {\n  try {\n    for (let i = 0; i < path.length; i++) {\n      const p = path[i];\n\n      if (isText(root) || !root.children[p]) {\n        return null;\n      }\n\n      root = root.children[p] as R;\n    }\n\n    return root as N;\n  } catch (error) {\n    return null;\n  }\n};\n","import { Node, Path } from 'slate';\n\nimport { AncestorOf } from './TAncestor';\nimport { TNode } from './TNode';\n\n/**\n * Get the node at a specific path, asserting that it's an ancestor node.\n */\nexport const getNodeAncestor = <\n  N extends AncestorOf<R>,\n  R extends TNode = TNode,\n>(\n  root: R,\n  path: Path\n) => Node.ancestor(root, path) as N;\n","import { Node, NodeAncestorsOptions, Path } from 'slate';\n\nimport { AncestorOf } from './TAncestor';\nimport { TNode } from './TNode';\nimport { TNodeEntry } from './TNodeEntry';\n\n/**\n * Return a generator of all the ancestor nodes above a specific path.\n *\n * By default the order is bottom-up, from lowest to highest ancestor in\n * the tree, but you can pass the `reverse: true` option to go top-down.\n */\nexport const getNodeAncestors = <\n  N extends AncestorOf<R>,\n  R extends TNode = TNode,\n>(\n  root: R,\n  path: Path,\n  options?: NodeAncestorsOptions\n) =>\n  Node.ancestors(root, path, options) as Generator<\n    TNodeEntry<N>,\n    void,\n    undefined\n  >;\n","import { Node } from 'slate';\n\nimport { ChildOf } from './TDescendant';\nimport { TNode } from './TNode';\n\n/**\n * Get the child of a node at a specific index.\n */\nexport const getNodeChild = <\n  N extends ChildOf<R, I>,\n  R extends TNode = TNode,\n  I extends number = number,\n>(\n  root: R,\n  index: I\n) => Node.child(root, index) as N;\n","import { Node, NodeChildrenOptions, Path } from 'slate';\n\nimport { ChildOf } from './TDescendant';\nimport { TNode } from './TNode';\nimport { TNodeEntry } from './TNodeEntry';\n\n/**\n * Iterate over the children of a node at a specific path.\n */\nexport const getNodeChildren = <N extends ChildOf<R>, R extends TNode = TNode>(\n  root: R,\n  path: Path,\n  options?: NodeChildrenOptions\n) =>\n  Node.children(root, path, options) as Generator<\n    TNodeEntry<N>,\n    void,\n    undefined\n  >;\n","import { Node, Path } from 'slate';\n\nimport { DescendantOf } from './TDescendant';\nimport { TNode } from './TNode';\n\n/**\n * Get the node at a specific path, asserting that it's a descendant node.\n */\nexport const getNodeDescendant = <\n  N extends DescendantOf<R>,\n  R extends TNode = TNode,\n>(\n  root: R,\n  path: Path\n) => Node.descendant(root, path) as N;\n","import { Modify } from '@udecode/utils';\nimport { Node, NodeDescendantsOptions } from 'slate';\n\nimport { DescendantOf } from './TDescendant';\nimport { TNode } from './TNode';\nimport { TDescendantEntry, TNodeEntry } from './TNodeEntry';\n\n/**\n * Return a generator of all the descendant node entries inside a root node.\n */\nexport const getNodeDescendants = <\n  N extends DescendantOf<R>,\n  R extends TNode = TNode,\n>(\n  root: R,\n  options?: Modify<\n    NonNullable<NodeDescendantsOptions>,\n    {\n      pass?: (node: TDescendantEntry<N>) => boolean;\n    }\n  >\n) =>\n  Node.descendants(root, options as any) as Generator<\n    TNodeEntry<N>,\n    void,\n    undefined\n  >;\n","import { Modify } from '@udecode/utils';\nimport { Node, NodeElementsOptions } from 'slate';\n\nimport { ElementOf } from '../element/TElement';\nimport { TNode } from './TNode';\nimport { TElementEntry, TNodeEntry } from './TNodeEntry';\n\n/**\n * Return a generator of all the element nodes inside a root node. Each iteration\n * will return an `ElementEntry` tuple consisting of `[Element, Path]`. If the\n * root node is an element it will be included in the iteration as well.\n */\nexport const getNodeElements = <\n  N extends ElementOf<R>,\n  R extends TNode = TNode,\n>(\n  root: R,\n  options?: Modify<\n    NonNullable<NodeElementsOptions>,\n    {\n      pass?: (node: TElementEntry<N>) => boolean;\n    }\n  >\n) =>\n  Node.elements(root, options as any) as Generator<\n    TNodeEntry<N>,\n    void,\n    undefined\n  >;\n","import { Node, Path } from 'slate';\n\nimport { NodeOf, TNode } from './TNode';\nimport { TNodeEntry } from './TNodeEntry';\n\n/**\n * Get the first node entry in a root node from a path.\n */\nexport const getNodeFirstNode = <N extends NodeOf<R>, R extends TNode = TNode>(\n  root: R,\n  path: Path\n) => Node.first(root, path) as TNodeEntry<N>;\n","import { Node, Range } from 'slate';\n\nimport { ElementOf } from '../element/TElement';\nimport { TextOf } from '../text/TText';\nimport { TNode } from './TNode';\n\n/**\n * Get the sliced fragment represented by a range inside a root node.\n */\nexport const getNodeFragment = <\n  N extends ElementOf<R> | TextOf<R>,\n  R extends TNode = TNode,\n>(\n  root: R,\n  range: Range\n) => Node.fragment(root, range) as Array<N>;\n","import { Node, Path } from 'slate';\n\nimport { NodeOf, TNode } from './TNode';\nimport { TNodeEntry } from './TNodeEntry';\n\n/**\n * Get the last node entry in a root node from a path.\n */\nexport const getNodeLastNode = <N extends NodeOf<R>, R extends TNode = TNode>(\n  root: R,\n  path: Path\n) => Node.last(root, path) as TNodeEntry<N>;\n","import { Node, Path } from 'slate';\n\nimport { TextOf } from '../text/TText';\nimport { TNode } from './TNode';\n\n/**\n * Get the node at a specific path, ensuring it's a leaf text node.\n */\nexport const getNodeLeaf = <N extends TextOf<R>, R extends TNode = TNode>(\n  root: R,\n  path: Path\n) => Node.leaf(root, path) as N;\n","import { Node, NodeLevelsOptions, Path } from 'slate';\n\nimport { NodeOf, TNode } from './TNode';\nimport { TNodeEntry } from './TNodeEntry';\n\n/**\n * Return a generator of the in a branch of the tree, from a specific path.\n *\n * By default the order is top-down, from lowest to highest node in the tree,\n * but you can pass the `reverse: true` option to go bottom-up.\n */\nexport const getNodeLevels = <N extends NodeOf<R>, R extends TNode = TNode>(\n  root: R,\n  path: Path,\n  options?: NodeLevelsOptions\n) =>\n  Node.levels(root, path, options) as Generator<TNodeEntry<N>, void, undefined>;\n","import { Node, Path } from 'slate';\n\nimport { AncestorOf } from './TAncestor';\nimport { TNode } from './TNode';\n\n/**\n * Get the parent of a node at a specific path.\n */\nexport const getNodeParent = <N extends AncestorOf<R>, R extends TNode = TNode>(\n  root: R,\n  path: Path\n) => Node.parent(root, path) as N;\n","import { Node } from 'slate';\n\nimport { TNode, TNodeProps } from './TNode';\n\n/**\n * Extract the custom properties from a node.\n */\nexport const getNodeProps = <N extends TNode>(node: N) =>\n  Node.extractProps(node) as TNodeProps<N>;\n","import { Node } from 'slate';\n\nimport { TNode } from './TNode';\n\n/**\n * Get the concatenated text string of a node's content.\n *\n * Note that this will not include spaces or line breaks between block nodes.\n * It is not a user-facing string, but a string for performing offset-related\n * computations for a node.\n */\nexport const getNodeString = (node: TNode) => Node.string(node);\n","import { Modify } from '@udecode/utils';\nimport { Node, NodeTextsOptions } from 'slate';\n\nimport { TextOf } from '../text/TText';\nimport { NodeOf, TNode } from './TNode';\nimport { TNodeEntry } from './TNodeEntry';\n\n/**\n * Return a generator of all leaf text nodes in a root node.\n */\nexport const getNodeTexts = <N extends TextOf<R>, R extends TNode = TNode>(\n  root: R,\n  options?: Modify<\n    NonNullable<NodeTextsOptions>,\n    {\n      pass?: (entry: TNodeEntry<NodeOf<N>>) => boolean;\n    }\n  >\n) =>\n  Node.texts(root, options as any) as Generator<TNodeEntry<N>, void, undefined>;\n","import { Modify } from '@udecode/utils';\nimport { Node, NodeNodesOptions } from 'slate';\n\nimport { NodeOf, TNode } from './TNode';\nimport { TNodeEntry } from './TNodeEntry';\n\n/**\n * Return a generator of all the node entries of a root node. Each entry is\n * returned as a `[Node, Path]` tuple, with the path referring to the node's\n * position inside the root node.\n */\nexport const getNodes = <N extends NodeOf<R>, R extends TNode = TNode>(\n  root: R,\n  options?: Modify<\n    NonNullable<NodeNodesOptions>,\n    {\n      pass?: (entry: TNodeEntry<NodeOf<N>>) => boolean;\n    }\n  >\n) =>\n  Node.nodes(root, options as any) as Generator<TNodeEntry<N>, void, undefined>;\n","import { Node, Path } from 'slate';\n\nimport { TNode } from './TNode';\n\n/**\n * Check if a descendant node exists at a specific path.\n */\nexport const hasNode = (root: TNode, path: Path) => Node.has(root, path);\n","import { Element } from 'slate';\n\nimport { TAncestor } from './TAncestor';\n\n/**\n * Check if a value implements the 'Ancestor' interface.\n */\nexport const isAncestor = (value: any): value is TAncestor =>\n  Element.isAncestor(value);\n","import { Node } from 'slate';\n\nimport { TNode } from './TNode';\n\n/**\n * Check if a value implements the `Node` interface.\n */\nexport const isNode = (value: any): value is TNode => Node.isNode(value);\n","import { Node } from 'slate';\n\nimport { TNode } from './TNode';\n\n/**\n * Check if a value is a list of `Node` objects.\n */\nexport const isNodeList = (value: any): value is TNode[] =>\n  Node.isNodeList(value);\n","import { Node } from 'slate';\n\nimport { TNode } from './TNode';\n\n/**\n * Check if a node matches a set of props.\n */\nexport const nodeMatches = (node: TNode, props: object) =>\n  Node.matches(node, props);\n","import { Range } from 'slate';\n\n/**\n * See {@link Range.isCollapsed}.\n * Return false if `range` is not defined.\n */\nexport const isCollapsed = (range?: Range | null) =>\n  !!range && Range.isCollapsed(range);\n","import { Range } from 'slate';\n\n/**\n * See {@link Range.isExpanded}.\n * Return false if `range` is not defined.\n */\nexport const isExpanded = (range?: Range | null) =>\n  !!range && Range.isExpanded(range);\n","import { Transforms } from 'slate';\nimport { SelectionCollapseOptions } from 'slate/dist/interfaces/transforms/selection';\n\nimport { TEditor, Value } from '../editor/TEditor';\n\n/**\n * Collapse the selection.\n */\nexport const collapseSelection = <V extends Value>(\n  editor: TEditor<V>,\n  options?: SelectionCollapseOptions\n) => {\n  Transforms.collapse(editor as any, options);\n};\n","import { Transforms } from 'slate';\n\nimport { TEditor, Value } from '../editor/TEditor';\n\n/**\n * Unset the selection.\n */\nexport const deselect = <V extends Value>(editor: TEditor<V>) => {\n  Transforms.deselect(editor as any);\n};\n","import { Transforms } from 'slate';\nimport { TextInsertFragmentOptions } from 'slate/dist/interfaces/transforms/text';\n\nimport { TEditor, Value } from '../editor/TEditor';\nimport { EElementOrText } from '../element/TElement';\n\n/**\n * Insert a fragment at a specific location in the editor.\n */\nexport const insertFragment = <\n  N extends EElementOrText<V>,\n  V extends Value = Value,\n>(\n  editor: TEditor<V>,\n  fragment: N[],\n  options?: TextInsertFragmentOptions\n) => {\n  Transforms.insertFragment(editor as any, fragment, options);\n};\n","import { Modify } from '@udecode/utils';\nimport { Path, removeNodes, Transforms, withoutNormalizing } from 'slate';\n\nimport { QueryNodeOptions } from '../../types';\nimport { NodeMatchOption } from '../../types/NodeMatchOption';\nimport { queryNode } from '../../utils';\nimport { getAboveNode, getEndPoint, isInline } from '../editor';\nimport { TEditor, Value } from '../editor/TEditor';\nimport { EElementOrText } from '../element/TElement';\nimport { getNodeString, TDescendant } from '../node';\n\nexport type InsertNodesOptions<V extends Value = Value> = Modify<\n  NonNullable<Parameters<typeof Transforms.insertNodes>[2]>,\n  NodeMatchOption<V>\n> & {\n  /**\n   * Remove the currect block if empty before inserting. Only applies to\n   * paragraphs by default, but can be customized by passing a\n   * QueryNodeOptions object.\n   */\n  removeEmpty?: boolean | QueryNodeOptions;\n\n  /**\n   * Insert the nodes after the currect block. Does not apply if the\n   * removeEmpty option caused the current block to be removed.\n   */\n  nextBlock?: boolean;\n};\n\n/**\n * Insert nodes at a specific location in the Editor.\n */\nexport const insertNodes = <\n  N extends EElementOrText<V>,\n  V extends Value = Value,\n>(\n  editor: TEditor<V>,\n  nodes: N | N[],\n  { nextBlock, removeEmpty, ...options }: InsertNodesOptions<V> = {}\n) => {\n  withoutNormalizing(editor as any, () => {\n    if (removeEmpty) {\n      const blockEntry = getAboveNode(editor, { at: options.at });\n\n      if (blockEntry) {\n        const queryNodeOptions: QueryNodeOptions =\n          removeEmpty === true\n            ? {\n                allow: ['p'],\n              }\n            : removeEmpty;\n\n        const { filter } = queryNodeOptions;\n\n        queryNodeOptions.filter = ([node, path]) => {\n          if (getNodeString(node)) return false;\n          const children = node.children as TDescendant[];\n          if (children.some((n) => isInline(editor, n))) return false;\n          return !filter || filter([node, path]);\n        };\n\n        if (queryNode(blockEntry, queryNodeOptions)) {\n          removeNodes(editor as any, { at: blockEntry[1] });\n          nextBlock = false;\n        }\n      }\n    }\n\n    if (nextBlock) {\n      const { at = editor.selection } = options;\n\n      if (at) {\n        const endPoint = getEndPoint(editor, at);\n\n        const blockEntry = getAboveNode(editor, {\n          at: endPoint,\n          block: true,\n        });\n\n        if (blockEntry) {\n          options.at = Path.next(blockEntry[1]);\n        }\n      }\n    }\n\n    Transforms.insertNodes(editor as any, nodes, options as any);\n  });\n};\n","import { TNode, TNodeEntry } from '../interfaces';\nimport { QueryNodeOptions } from '../types/QueryNodeOptions';\n\nfunction castArray<T>(value: T | T[]): T[] {\n  return Array.isArray(value) ? value : [value];\n}\n\n/**\n * Query the node entry.\n */\nexport const queryNode = <N extends TNode>(\n  entry?: TNodeEntry<N>,\n  { filter, allow, exclude, level, maxLevel }: QueryNodeOptions = {}\n) => {\n  if (!entry) return false;\n\n  const [node, path] = entry;\n\n  if (level) {\n    const levels = castArray(level);\n\n    if (!levels.includes(path.length)) {\n      return false;\n    }\n  }\n\n  if (maxLevel && path.length > maxLevel) {\n    return false;\n  }\n\n  if (filter && !filter(entry)) {\n    return false;\n  }\n\n  if (allow) {\n    const allows = castArray(allow);\n\n    if (allows.length > 0 && !allows.includes(node.type as any)) {\n      return false;\n    }\n  }\n\n  if (exclude) {\n    const excludes = castArray(exclude);\n\n    if (excludes.length > 0 && excludes.includes(node.type as any)) {\n      return false;\n    }\n  }\n\n  return true;\n};\n","import { Transforms } from 'slate';\nimport { TextInsertTextOptions } from 'slate/dist/interfaces/transforms/text';\n\nimport { TEditor, Value } from '../editor/TEditor';\n\n/**\n * Insert a string of text in the Editor.\n */\nexport const insertText = <V extends Value>(\n  editor: TEditor<V>,\n  text: string,\n  options?: TextInsertTextOptions\n) => {\n  Transforms.insertText(editor as any, text, options);\n};\n","import { Modify } from '@udecode/utils';\nimport { Transforms } from 'slate';\n\nimport { NodeMatchOption } from '../../types/NodeMatchOption';\nimport { TEditor, Value } from '../editor/TEditor';\n\nexport type LiftNodesOptions<V extends Value = Value> = Modify<\n  NonNullable<Parameters<typeof Transforms.liftNodes>[1]>,\n  NodeMatchOption<V>\n>;\n\n/**\n * Lift nodes at a specific location upwards in the document tree, splitting\n * their parent in two if necessary.\n */\nexport const liftNodes = <V extends Value>(\n  editor: TEditor<V>,\n  options?: LiftNodesOptions<V>\n) => Transforms.liftNodes(editor as any, options as any);\n","import { Transforms } from 'slate';\nimport { SelectionMoveOptions } from 'slate/dist/interfaces/transforms/selection';\n\nimport { TEditor, Value } from '../editor/TEditor';\n\n/**\n * Move the selection's point forward or backward.\n */\nexport const moveSelection = <V extends Value>(\n  editor: TEditor<V>,\n  options?: SelectionMoveOptions\n) => {\n  Transforms.move(editor as any, options);\n};\n","import { Modify } from '@udecode/utils';\nimport { Transforms } from 'slate';\n\nimport { NodeMatchOption } from '../../types/NodeMatchOption';\nimport { TEditor, Value } from '../editor/TEditor';\nimport { ENode, TNodeProps } from '../node/TNode';\n\nexport type SetNodesOptions<V extends Value = Value> = Modify<\n  NonNullable<Parameters<typeof Transforms.setNodes>[2]>,\n  NodeMatchOption<V>\n>;\n\n/**\n * Set new properties on the nodes at a location.\n */\nexport const setNodes = <N extends ENode<V>, V extends Value = Value>(\n  editor: TEditor<V>,\n  props: Partial<TNodeProps<N>>,\n  options?: SetNodesOptions<V>\n) => Transforms.setNodes(editor as any, props, options as any);\n","import { Point, Transforms } from 'slate';\nimport { SelectionSetPointOptions } from 'slate/dist/interfaces/transforms/selection';\n\nimport { TEditor, Value } from '../editor/TEditor';\n\n/**\n * Set new properties on one of the selection's points.\n */\nexport const setPoint = <V extends Value>(\n  editor: TEditor<V>,\n  props: Partial<Point>,\n  options?: SelectionSetPointOptions\n) => {\n  Transforms.setPoint(editor as any, props, options);\n};\n","import { Range, Transforms } from 'slate';\n\nimport { TEditor, Value } from '../editor/TEditor';\n\n/**\n * Set new properties on the selection.\n */\nexport const setSelection = <V extends Value>(\n  editor: TEditor<V>,\n  props: Partial<Range>\n) => {\n  Transforms.setSelection(editor as any, props);\n};\n","import { Modify } from '@udecode/utils';\nimport { Transforms } from 'slate';\n\nimport { NodeMatchOption } from '../../types/NodeMatchOption';\nimport { TEditor, Value } from '../editor/TEditor';\n\nexport type SplitNodesOptions<V extends Value = Value> = Modify<\n  NonNullable<Parameters<typeof Transforms.splitNodes>[1]>,\n  NodeMatchOption<V>\n>;\n\n/**\n * Split the nodes at a specific location.\n */\nexport const splitNodes = <V extends Value>(\n  editor: TEditor<V>,\n  options?: SplitNodesOptions<V>\n) => Transforms.splitNodes(editor as any, options as any);\n","import { Modify } from '@udecode/utils';\nimport { Transforms } from 'slate';\n\nimport { NodeMatchOption } from '../../types/NodeMatchOption';\nimport { TEditor, Value } from '../editor/TEditor';\nimport { ENode, TNodeProps } from '../node/TNode';\n\nexport type UnsetNodesOptions<V extends Value = Value> = Modify<\n  NonNullable<Parameters<typeof Transforms.unsetNodes>[2]>,\n  NodeMatchOption<V>\n>;\n\n/**\n * Unset properties on the nodes at a location.\n */\nexport const unsetNodes = <N extends ENode<V>, V extends Value = Value>(\n  editor: TEditor<V>,\n  props: keyof TNodeProps<N> | (keyof TNodeProps<N>)[],\n  options?: UnsetNodesOptions<V>\n) => {\n  return Transforms.unsetNodes(editor as any, props as any, options as any);\n};\n","import { Modify } from '@udecode/utils';\nimport { Transforms } from 'slate';\n\nimport { ENodeMatchOptions, getQueryOptions } from '../../utils/match';\nimport { TEditor, Value } from '../editor/TEditor';\n\nexport type UnwrapNodesOptions<V extends Value = Value> = Modify<\n  NonNullable<Parameters<typeof Transforms.unwrapNodes>[1]>,\n  ENodeMatchOptions<V>\n>;\n\n/**\n * Unwrap the nodes at a location from a parent node, splitting the parent if\n * necessary to ensure that only the content in the range is unwrapped.\n */\nexport const unwrapNodes = <V extends Value>(\n  editor: TEditor<V>,\n  options?: UnwrapNodesOptions<V>\n) => {\n  Transforms.unwrapNodes(editor as any, getQueryOptions(editor, options));\n};\n","import { Modify } from '@udecode/utils';\nimport { Transforms } from 'slate';\n\nimport { NodeMatchOption } from '../../types/NodeMatchOption';\nimport { TEditor, Value } from '../editor/TEditor';\nimport { unhangRange } from '../editor/unhangRange';\nimport { EElement } from '../element/TElement';\n\nexport type WrapNodesOptions<V extends Value = Value> = Modify<\n  NonNullable<Parameters<typeof Transforms.wrapNodes>[2]>,\n  NodeMatchOption<V>\n>;\n\n/**\n * Wrap the nodes at a location in a new container node, splitting the edges\n * of the range first to ensure that only the content in the range is wrapped.\n */\nexport const wrapNodes = <N extends EElement<V>, V extends Value = Value>(\n  editor: TEditor<V>,\n  element: N,\n  options?: WrapNodesOptions<V>\n) => {\n  unhangRange(editor, options?.at, options);\n\n  Transforms.wrapNodes(editor as any, element as any, options as any);\n};\n","import {\n  ENode,\n  getNodeEntries,\n  GetNodeEntriesOptions,\n  TEditor,\n  TNodeEntry,\n  Value,\n} from '../interfaces';\nimport { getQueryOptions } from '../utils';\n\nexport type FindNodeOptions<V extends Value = Value> = GetNodeEntriesOptions<V>;\n\n/**\n * Find node matching the condition.\n */\nexport const findNode = <N extends ENode<V>, V extends Value = Value>(\n  editor: TEditor<V>,\n  options: FindNodeOptions<V> = {}\n): TNodeEntry<N> | undefined => {\n  // Slate throws when things aren't found so we wrap in a try catch and return undefined on throw.\n  try {\n    const nodeEntries = getNodeEntries<N, V>(editor, {\n      at: editor.selection || [],\n      ...getQueryOptions(editor, options),\n    });\n\n    // eslint-disable-next-line no-unreachable-loop\n    for (const [node, path] of nodeEntries) {\n      return [node, path];\n    }\n  } catch (error) {\n    return undefined;\n  }\n};\n","import { ENode, TEditor, Value } from '../interfaces';\nimport { findNode, FindNodeOptions } from './findNode';\n\n/**\n * Iterate through all of the nodes in the editor and break early for the first truthy match. Otherwise\n * returns false.\n */\nexport const someNode = <N extends ENode<V>, V extends Value = Value>(\n  editor: TEditor<V>,\n  options: FindNodeOptions<V>\n) => {\n  return !!findNode<N, V>(editor, options);\n};\n","import { Editor, Location, Node, Path, Range, Text, Transforms } from 'slate';\n\nimport { getRange } from '../interfaces';\nimport { TEditor, Value } from '../interfaces/editor/TEditor';\n\n/**\n * Add marks to each node of a range.\n */\nexport const addRangeMarks = <V extends Value>(\n  editor: TEditor<V>,\n  props: any,\n  {\n    at = editor.selection,\n  }: {\n    at?: Location | null;\n  } = {}\n) => {\n  if (at) {\n    if (Path.isPath(at)) {\n      at = getRange(editor as any, at);\n    }\n\n    const match = (node: Node, path: Path) => {\n      if (!Text.isText(node)) {\n        return false; // marks can only be applied to text\n      }\n      const parentEntry = Editor.parent(editor as any, path);\n      if (!parentEntry) return false;\n\n      const [parentNode] = parentEntry;\n\n      return (\n        !editor.isVoid(parentNode as any) ||\n        editor.markableVoid(parentNode as any)\n      );\n    };\n    const isExpandedRange = Range.isExpanded(at as Range);\n    let markAcceptingVoidSelected = false;\n    if (!isExpandedRange) {\n      const selectedEntry = Editor.node(editor as any, at);\n      if (!selectedEntry) return;\n\n      const [selectedNode, selectedPath] = selectedEntry;\n\n      if (selectedNode && match(selectedNode, selectedPath)) {\n        const parentEntry = Editor.parent(editor as any, selectedPath);\n        if (!parentEntry) return;\n\n        const [parentNode] = parentEntry;\n\n        markAcceptingVoidSelected =\n          parentNode && editor.markableVoid(parentNode as any);\n      }\n    }\n    if (isExpandedRange || markAcceptingVoidSelected) {\n      Transforms.setNodes(editor as any, props, {\n        match,\n        split: true,\n        voids: true,\n        at,\n      });\n    }\n    // else {\n    //   const marks = {\n    //     ...(Editor.marks(editor as any) || {}),\n    //     [key]: value,\n    //   };\n    //\n    //   editor.marks = marks;\n    //   if (!FLUSHING.get(editor as any)) {\n    //     editor.onChange();\n    //   }\n    // }\n  }\n};\n","import { TEditor, TElement, TNodeProps, Value } from '../interfaces';\nimport { setNodes, SetNodesOptions } from '../interfaces/transforms/setNodes';\n\nexport const setElements = <V extends Value>(\n  editor: TEditor<V>,\n  props: Partial<TNodeProps<TElement>>,\n  options?: SetNodesOptions\n) => setNodes<TElement>(editor, props, options);\n","import { Path, Range } from 'slate';\n\nimport { getPointAfter, getPointBefore, TEditor, Value } from '../interfaces';\n\n/**\n * Unhang the range of length 1 so both edges are in the same text node.\n */\nexport const unhangCharacterRange = <V extends Value>(\n  editor: TEditor<V>,\n  at: Range\n) => {\n  let [start, end] = Range.edges(at);\n\n  if (!Path.equals(start.path, end.path)) {\n    if (end.offset === 0) {\n      const pointAfter = getPointAfter(editor, start);\n      if (pointAfter) {\n        end = pointAfter;\n      }\n    } else {\n      const pointBefore = getPointBefore(editor, end);\n      if (pointBefore) {\n        start = pointBefore;\n      }\n    }\n  }\n\n  return { anchor: start, focus: end };\n};\n"],"mappings":"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","names":["Editor","Editor","Editor","Editor","Editor","Editor","Editor","Path","Point","Range","Editor","Path","Range","Editor","Editor","Element","Element","Editor","Editor","Editor","Editor","Range","Editor","Editor","Editor","Editor","Editor","Transforms","Transforms","Transforms","match","Path","Range","Editor","Editor","Editor","Editor","Editor","Editor","Editor","Editor","Editor","Range","Point","Path","Editor","point","Editor","Editor","Editor","Editor","Editor","Editor","Editor","Editor","Editor","Editor","Editor","Editor","Editor","Editor","Editor","Editor","Editor","Editor","Editor","Editor","Editor","Editor","Editor","Editor","Editor","Editor","Editor","Editor","Editor","Editor","HistoryEditor","HistoryEditor","HistoryEditor","HistoryEditor","Text","Text","Text","Node","Node","Node","Node","Node","Node","Node","Node","Node","Node","Node","Node","Node","Node","Node","Node","Node","Node","Element","Node","Node","Node","Range","Range","Transforms","Transforms","Transforms","Path","removeNodes","Transforms","withoutNormalizing","castArray","withoutNormalizing","removeNodes","Path","Transforms","Transforms","Transforms","Transforms","Transforms","Transforms","Transforms","Transforms","Transforms","Transforms","Transforms","Transforms","Transforms","Editor","Path","Range","Text","Transforms","Path","match","Text","Editor","Range","Transforms","Path","Range","Range","Path"]}